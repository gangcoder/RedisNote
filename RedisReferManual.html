<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>PHPREDIS中文手册</title>
</head>
<body>
<a name="top"></a>

<div id="topics">
<p><span class="Apple-style-span" style="line-height: 21px; font-size: 14px; font-weight: normal;">参考《redis中文手册》，示例代码PHP实现，注意php-redis与redis_cli的区别（主要是返回值类型和参数用法）。</span></p>
<p><strong>目录(使用CTRL+F快速查找命令)：</strong></p>
<table rules="all" class="docutils" style="width: 90%;" border="1"><colgroup> <col width="20%" /> <col width="20%" /> <col width="20%" /> <col width="20%" /> <col width="20%" /></colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Key</th><th class="head">String</th><th class="head">Hash</th><th class="head">List</th><th class="head">Set</th></tr>
</thead>
<tbody valign="top">
<tr class="row-even">
<td>
<div style="margin: 0px; padding: 0px;">
<ul style="margin: 0px; padding: 0px;">
<li class="toctree-l1"><a class="reference internal" href="#key_del">键(Key)</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="#key_del">DEL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#key_keys">KEYS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#key_RANDOMKEY">RANDOMKEY</a></li>
<li class="toctree-l2"><a class="reference internal" href="#key_TTL">TTL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#key_EXISTS">EXISTS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#key_move">MOVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#key_RENAME">RENAME</a></li>
<li class="toctree-l2"><a href="#key_RENAMENX">RENAMENX</a></li>
<li class="toctree-l2"><a class="reference internal" href="#key_TYPE">TYPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#key_EXPIRE">EXPIRE</a></li>
<li class="toctree-l2"><a href="#key_EXPIREAT">EXPIREAT</a></li>
<li class="toctree-l2"><a href="#key_OBJECT">OBJECT</a></li>
<li class="toctree-l2"><a href="#key_PERSIST">PERSIST</a></li>
<li class="toctree-l2"><a href="#key_SORT">SORT</a></li>
</ul>
</li>
</ul>
</div>
</td>
<td>
<div style="margin: 0px; padding: 0px;">
<ul style="margin: 0px; padding: 0px;">
<li class="toctree-l1"><a href="#STRING">字符串(String)</a>
<ul>
<li class="toctree-l2"><a href="#string_SET">SET</a></li>
<li class="toctree-l2"><a href="#string_SETNX">SETNX</a></li>
<li class="toctree-l2"><a href="#string_SETEX">SETEX</a></li>
<li class="toctree-l2"><a href="#string_SETRANGE">SETRANGE</a></li>
<li class="toctree-l2"><a href="#string_MSET">MSET</a></li>
<li class="toctree-l2"><a href="#string_MSETNX">MSETNX</a></li>
<li class="toctree-l2"><a href="#string_APPEND">APPEND</a></li>
<li class="toctree-l2"><a href="#string_GET">GET</a></li>
<li class="toctree-l2"><a href="#string_MGET">MGET</a></li>
<li class="toctree-l2"><a href="#string_GETRANGE">GETRANGE</a></li>
<li class="toctree-l2"><a href="#string_GETSET">GETSET</a></li>
<li class="toctree-l2"><a href="#string_STRLEN">STRLEN</a></li>
<li class="toctree-l2"><a href="#string_INCR">INCR</a></li>
<li class="toctree-l2"><a href="#string_INCRBY">INCRBY</a></li>
<li class="toctree-l2"><a href="#string_DECR">DECR</a></li>
<li class="toctree-l2"><a href="#string_DECRBY">DECRBY</a></li>
<li class="toctree-l2"><a href="#string_SETBIT">SETBIT</a></li>
<li class="toctree-l2"><a href="#string_GETBIT">GETBIT</a></li>
</ul>
</li>
</ul>
</div>
</td>
<td>
<div style="margin: 0px; padding: 0px;">
<ul style="margin: 0px; padding: 0px;">
<li class="toctree-l1"><a href="#hash">哈希表(Hash)</a>
<ul>
<li class="toctree-l2"><a href="#hash_HSET">HSET</a></li>
<li class="toctree-l2"><a href="#hash_HSETNX">HSETNX</a></li>
<li class="toctree-l2"><a href="#hash_HMSET">HMSET</a></li>
<li class="toctree-l2"><a href="#hash_HGET">HGET</a></li>
<li class="toctree-l2"><a href="#hash_HMGET">HMGET</a></li>
<li class="toctree-l2"><a href="#hash_HGETALL">HGETALL</a></li>
<li class="toctree-l2"><a href="#hash_HDEL">HDEL</a></li>
<li class="toctree-l2"><a href="#hash_HLEN">HLEN</a></li>
<li class="toctree-l2"><a href="#hash_HEXISTS">HEXISTS</a></li>
<li class="toctree-l2"><a href="#hash_HINCRBY">HINCRBY</a></li>
<li class="toctree-l2"><a href="#hash_HKEYS">HKEYS</a></li>
<li class="toctree-l2"><a href="#hash_HVALS">HVALS</a></li>
</ul>
</li>
</ul>
</div>
</td>
<td>
<div style="margin: 0px; padding: 0px;">
<ul style="margin: 0px; padding: 0px;">
<li class="toctree-l1"><a href="#list">表(List)</a>
<ul>
<li class="toctree-l2"><a href="#list_LPUSH">LPUSH</a></li>
<li class="toctree-l2"><a href="#list_LPUSHX">LPUSHX</a></li>
<li class="toctree-l2"><a href="#list_RPUSH">RPUSH</a></li>
<li class="toctree-l2"><a href="#list_RPUSHX">RPUSHX</a></li>
<li class="toctree-l2"><a href="#list_LPOP">LPOP</a></li>
<li class="toctree-l2"><a href="#list_RPOP">RPOP</a></li>
<li class="toctree-l2"><a href="#list_BLPOP">BLPOP</a></li>
<li class="toctree-l2"><a href="#list_BRPOP">BRPOP</a></li>
<li class="toctree-l2"><a href="#list_LLEN">LLEN</a></li>
<li class="toctree-l2"><a href="#list_LRANGE">LRANGE</a></li>
<li class="toctree-l2"><a href="#list_LREM">LREM</a></li>
<li class="toctree-l2"><a href="#list_LSET">LSET</a></li>
<li class="toctree-l2"><a href="#list_LTRIM">LTRIM</a></li>
<li class="toctree-l2"><a href="#list_LINDEX">LINDEX</a></li>
<li class="toctree-l2"><a href="#list_LINSERT">LINSERT</a></li>
<li class="toctree-l2"><a href="#list_RPOPLPUSH">RPOPLPUSH</a></li>
<li class="toctree-l2"><a href="#list_BRPOPLPUSH">BRPOPLPUSH</a></li>
</ul>
</li>
</ul>
</div>
</td>
<td>
<div style="margin: 0px; padding: 0px;">
<ul style="margin: 0px; padding: 0px;">
<li class="toctree-l1"><a href="#set">集合(Set)</a>
<ul>
<li class="toctree-l2"><a href="#set_SADD">SADD</a></li>
<li class="toctree-l2"><a href="#set_SREM">SREM</a></li>
<li class="toctree-l2"><a href="#set_SMEMBERS">SMEMBERS</a></li>
<li class="toctree-l2"><a href="#set_SISMEMBER">SISMEMBER</a></li>
<li class="toctree-l2"><a href="#set_SCARD">SCARD</a></li>
<li class="toctree-l2"><a href="#set_SMOVE">SMOVE</a></li>
<li class="toctree-l2"><a href="#set_SPOP">SPOP</a></li>
<li class="toctree-l2"><a href="#set_SRANDMEMBER">SRANDMEMBER</a></li>
<li class="toctree-l2"><a href="#set_SINTER">SINTER</a></li>
<li class="toctree-l2"><a href="#set_SINTERSTORE">SINTERSTORE</a></li>
<li class="toctree-l2"><a href="#set_SUNION">SUNION</a></li>
<li class="toctree-l2"><a href="#set_SUNIONSTORE">SUNIONSTORE</a></li>
<li class="toctree-l2"><a href="#set_SDIFF">SDIFF</a></li>
<li class="toctree-l2"><a href="#set_SDIFFSTORE">SDIFFSTORE</a></li>
</ul>
</li>
</ul>
</div>
</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line">&nbsp;</div>
</div>
<table rules="all" class="docutils" style="width: 90%;" border="1"><colgroup> <col width="20%" /> <col width="20%" /> <col width="20%" /> <col width="20%" /> <col width="20%" /></colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Sorted Set</th><th class="head">Pub/Sub</th><th class="head">Transaction</th><th class="head">Connection</th><th class="head">Server</th></tr>
</thead>
<tbody valign="top">
<tr class="row-even">
<td>
<div style="margin: 0px; padding: 0px;">
<ul style="margin: 0px; padding: 0px;">
<li class="toctree-l1"><a href="#Sorted-Set">有序集(Sorted Set)</a>
<ul>
<li class="toctree-l2"><a href="#z_ZADD">ZADD</a></li>
<li class="toctree-l2"><a href="#z_ZREM">ZREM</a></li>
<li class="toctree-l2"><a href="#z_ZCARD">ZCARD</a></li>
<li class="toctree-l2"><a href="#z_ZCOUNT">ZCOUNT</a></li>
<li class="toctree-l2"><a href="#z_ZSCORE">ZSCORE</a></li>
<li class="toctree-l2"><a href="#z_ZINCRBY">ZINCRBY</a></li>
<li class="toctree-l2"><a href="#z_ZRANGE">ZRANGE</a></li>
<li class="toctree-l2"><a href="#z_ZREVRANGE">ZREVRANGE</a></li>
<li class="toctree-l2"><a href="#z_ZRANGEBYSCORE">ZRANGEBYSCORE</a></li>
<li class="toctree-l2"><a href="#z_ZREVRANGEBYSCORE">ZREVRANGEBYSCORE</a></li>
<li class="toctree-l2"><a href="#z_ZRANK">ZRANK</a></li>
<li class="toctree-l2"><a href="#z_ZREVRANK">ZREVRANK</a></li>
<li class="toctree-l2"><a href="#z_ZREMRANGEBYRANK">ZREMRANGEBYRANK</a></li>
<li class="toctree-l2"><a href="#z_ZREMRANGEBYSCORE">ZREMRANGEBYSCORE</a></li>
<li class="toctree-l2"><a href="#z_ZINTERSTORE">ZINTERSTORE</a></li>
<li class="toctree-l2"><a href="#z_ZUNIONSTORE">ZUNIONSTORE</a></li>
</ul>
</li>
</ul>
</div>
</td>
<td>
<div style="margin: 0px; padding: 0px;">
<ul style="margin: 0px; padding: 0px;">
<li class="toctree-l1"><a href="#pub_sub">发布/订阅(Pub/Sub)</a>
<ul>
<li class="toctree-l2"><a href="#ps_PUBLISH">PUBLISH</a></li>
<li class="toctree-l2"><a href="#ps_SUBSCRIBE">SUBSCRIBE</a></li>
<li class="toctree-l2"><a href="#ps_PSUBSCRIBE">PSUBSCRIBE</a></li>
<li class="toctree-l2"><a href="#ps_UNSUBSCRIBE">UNSUBSCRIBE</a></li>
<li class="toctree-l2"><a href="#ps_PUNSUBSCRIBE">PUNSUBSCRIBE</a></li>
</ul>
</li>
</ul>
</div>
</td>
<td>
<div style="margin: 0px; padding: 0px;">
<ul style="margin: 0px; padding: 0px;">
<li class="toctree-l1"><a href="#Transaction">事务(Transaction)</a>
<ul>
<li class="toctree-l2"><a href="#t_WATCH">WATCH</a></li>
<li class="toctree-l2"><a href="#t_UNWATCH">UNWATCH</a></li>
<li class="toctree-l2"><a href="#t_MULTI">MULTI</a></li>
<li class="toctree-l2"><a href="#t_EXEC">EXEC</a></li>
<li class="toctree-l2"><a href="#t_DISCARD">DISCARD</a></li>
</ul>
</li>
</ul>
</div>
</td>
<td>
<div style="margin: 0px; padding: 0px;">
<ul style="margin: 0px; padding: 0px;">
<li class="toctree-l1"><a href="#Connection">连接(Connection)</a>
<ul>
<li class="toctree-l2"><a href="#conn_AUTH">AUTH</a></li>
<li class="toctree-l2"><a href="#conn_PING">PING</a></li>
<li class="toctree-l2"><a href="#conn_SELECT">SELECT</a></li>
<li class="toctree-l2"><a href="#conn_ECHO">ECHO</a></li>
<li class="toctree-l2"><a href="#conn_QUIT">QUIT</a></li>
</ul>
</li>
</ul>
</div>
</td>
<td>
<div style="margin: 0px; padding: 0px;">
<ul style="margin: 0px; padding: 0px;">
<li class="toctree-l1"><a href="#Server">服务器(Server)</a>
<ul>
<li class="toctree-l2"><a href="#svr_BGREWRITEAOF">BGREWRITEAOF</a></li>
<li class="toctree-l2"><a href="#svr_BGSAVE">BGSAVE</a></li>
<li class="toctree-l2"><a href="#svr_SAVE">SAVE</a></li>
<li class="toctree-l2"><a href="#svr_LASTSAVE">LASTSAVE</a></li>
<li class="toctree-l2"><a href="#svr_DBSIZE">DBSIZE</a></li>
<li class="toctree-l2"><a href="#svr_SLAVEOF">SLAVEOF</a></li>
<li class="toctree-l2"><a href="#svr_FLUSHALL">FLUSHALL</a></li>
<li class="toctree-l2"><a href="#svr_FLUSHDB">FLUSHDB</a></li>
<li class="toctree-l2"><a href="#svr_SHUTDOWN">SHUTDOWN</a></li>
<li class="toctree-l2"><a href="#svr_SLOWLOG">SLOWLOG</a></li>
<li class="toctree-l2"><a href="#svr_INFO">INFO</a></li>
<li class="toctree-l2"><a href="#svr_CONFIG-GET">CONFIG GET</a></li>
<li class="toctree-l2"><a href="#scr_CONFIG-SET">CONFIG SET</a></li>
<li class="toctree-l2"><a href="#scr_CONFIG-RESETSTAT">CONFIG RESETSTAT</a></li>
<li class="toctree-l2"><a href="#scr_DEBUG-OBJECT">DEBUG OBJECT</a></li>
<li class="toctree-l2"><a href="#svr_DEBUG-SEGFAULT">DEBUG SEGFAULT</a></li>
<li class="toctree-l2"><a href="#svr_MONITOR">MONITOR</a></li>
<li class="toctree-l2"><a href="#svr_SYNC">SYNC</a></li>
</ul>
</li>
</ul>
</div>
</td>
</tr>
</tbody>
</table>
<p>phpredis是redis的php的一个扩展，效率是相当高有链表排序功能，对创建内存级的模块业务关系</p>
<div id="post_content">
<p>很有用;以下是redis官方提供的命令使用技巧:</p>
<p>下载地址如下：</p>
<p>https://github.com/owlient/phpredis（支持redis 2.0.4）</p>
<p>Redis::__construct构造函数<br />$redis = new Redis();</p>
<p><span style="color: #ff0000;">connect</span>, open 链接redis服务<br />参数<br />host: string，服务地址<br />port: int,端口号<br />timeout: float,链接时长 (可选, 默认为 0 ，不限链接时间)<br />注: 在redis.conf中也有时间，默认为300</p>
<p><span style="color: #ff0000;">pconnect</span>, popen 不会主动关闭的链接<br />参考上面</p>
<p>setOption 设置redis模式</p>
<p>getOption 查看redis设置的模式</p>
<p><span style="color: #ff0000;">ping</span> 查看连接状态</p>
<p>&nbsp;</p>
<p><strong>KEY相关操作</strong></p>
<p><strong><a name="key_del"></a><span style="font-size: 18pt;">DEL</span></strong></p>
<p>移除给定的一个或多个<tt class="docutils literal"><span class="pre">key</span></tt>。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，则忽略该命令。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>
<div class="first line-block">
<div class="line">O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为要移除的<tt class="docutils literal"><span class="pre">key</span></tt>的数量。</div>
</div>
<div class="last line-block">
<div class="line">移除单个字符串类型的<tt class="docutils literal"><span class="pre">key</span></tt>，时间复杂度为O(1)。</div>
<div class="line">移除单个列表、集合、有序集合或哈希表类型的<tt class="docutils literal"><span class="pre">key</span></tt>，时间复杂度为O(M)，<tt class="docutils literal"><span class="pre">M</span></tt>为以上数据结构内的元素数量。</div>
</div>
</dd><dt><strong>返回值：</strong></dt><dd>被移除<tt class="docutils literal"><span class="pre">key</span></tt>的数量。</dd></dl>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">DEL</span><span style="color: #008000;"><br />#</span><span style="color: #008000;"> 情况1： 删除单个key</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;set('myname','ikodota');<br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;get('myname').'&lt;br&gt;'; <span style="color: #008000;">#</span><span style="color: #008000;"> 返回:ikodota</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;del('myname');<span style="color: #008000;">#</span><span style="color: #008000;"> 返回 TRUE(1)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;get('myname')); <span style="color: #008000;">#</span><span style="color: #008000;"> 返回 bool(false)</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2： 删除一个不存在的key</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">if</span>(!<span style="color: #800080;">$redis</span>-&gt;exists('fake_key')) <span style="color: #008000;">#</span><span style="color: #008000;"> 不存在</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;del('fake_key')); <span style="color: #008000;">#</span><span style="color: #008000;"> 返回 int(0)</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况3： 同时删除多个key</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$array_mset</span>=<span style="color: #0000ff;">array</span>('first_key'=&gt;'first_val',<br />          'second_key'=&gt;'second_val',<br />          'third_key'=&gt;'third_val');<br /><span style="color: #800080;">$redis</span>-&gt;mset(<span style="color: #800080;">$array_mset</span>); <span style="color: #008000;">#</span><span style="color: #008000;">用MSET一次储存多个值</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$array_mget</span>=<span style="color: #0000ff;">array</span>('first_key','second_key','third_key');<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;mget(<span style="color: #800080;">$array_mget</span>)); <span style="color: #008000;">#</span><span style="color: #008000;">一次返回多个值 //array(3) { [0]=&gt; string(9) "first_val" [1]=&gt; string(10) "second_val" [2]=&gt; string(9) "third_val" }</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;<strong>del</strong>(<span style="color: #800080;">$array_mget</span>); <span style="color: #008000;">#</span><span style="color: #008000;">同时删除多个key</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;mget(<span style="color: #800080;">$array_mget</span>)); <span style="color: #008000;">#</span><span style="color: #008000;">返回 array(3) { [0]=&gt; bool(false) [1]=&gt; bool(false) [2]=&gt; bool(false) }</span></pre>
</div>
<p><span style="color: #ff0000;">&nbsp;</span></p>
<dl class="function"><dt><strong><tt class="descname"><a name="key_keys"></a><span style="font-size: 18pt;">KEYS</span></tt></strong></dt><dt><tt class="descname">KEYS pattern&nbsp;</tt></dt><dt><tt class="descname"></tt>查找符合给定模式的<tt class="docutils literal"><span class="pre">key</span></tt>。</dt></dl>
<div class="line-block">
<div class="line"><tt class="docutils literal"><span class="pre">KEYS</span>&nbsp;<span class="pre">*</span></tt>命中数据库中所有<tt class="docutils literal"><span class="pre">key</span></tt>。</div>
<div class="line"><tt class="docutils literal"><span class="pre">KEYS</span>&nbsp;<span class="pre">h?llo</span></tt>命中<tt class="docutils literal"><span class="pre">hello</span></tt>，&nbsp;<tt class="docutils literal"><span class="pre">hallo</span>&nbsp;<span class="pre">and</span>&nbsp;<span class="pre">hxllo</span></tt>等。</div>
<div class="line"><tt class="docutils literal"><span class="pre">KEYS</span>&nbsp;<span class="pre">h*llo</span></tt>命中<tt class="docutils literal"><span class="pre">hllo</span></tt>和<tt class="docutils literal"><span class="pre">heeeeello</span></tt>等。</div>
<div class="line"><tt class="docutils literal"><span class="pre">KEYS</span>&nbsp;<span class="pre">h[ae]llo</span></tt>命中<tt class="docutils literal"><span class="pre">hello</span></tt>和<tt class="docutils literal"><span class="pre">hallo</span></tt>，但不命中<tt class="docutils literal"><span class="pre">hillo</span></tt>。</div>
</div>
<p>特殊符号用<tt class="docutils literal"><span class="pre">"\"</span></tt>隔开</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为数据库中<tt class="docutils literal"><span class="pre">key</span></tt>的数量。</dd><dt><strong>返回值：</strong></dt><dd>符合给定模式的<tt class="docutils literal"><span class="pre">key</span></tt>列表。</dd></dl>
<div class="admonition warning">
<p class="first admonition-title"><span style="color: #ff0000;">警告 :<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/key.html#keys"><span style="color: #ff0000;">KEYS</span></a>的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的<tt class="docutils literal"><span class="pre">key</span></tt>，你最好还是用<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/set.html#set-struct"><span style="color: #ff0000;"><em>集合(Set)</em></span></a>。</span></p>
</div>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">KEYS</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">$redis-&gt;FLUSHALL();</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$array_mset_keys</span>=<span style="color: #0000ff;">array</span>('one'=&gt;'1',<br />          'two'=&gt;'2',<br />          'three '=&gt;'3',<br />          'four'=&gt;'4');<br /><span style="color: #800080;">$redis</span>-&gt;mset(<span style="color: #800080;">$array_mset_keys</span>); <span style="color: #008000;">#</span><span style="color: #008000;">用MSET一次储存多个值</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;keys('*o*')); <span style="color: #008000;">//</span><span style="color: #008000;">array(3) { [0]=&gt; string(4) "four" [1]=&gt; string(3) "two" [2]=&gt; string(3) "one" }</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;keys('t??')); <span style="color: #008000;">//</span><span style="color: #008000;">array(1) { [0]=&gt; string(3) "two" }</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;keys('t[w]*')); <span style="color: #008000;">//</span><span style="color: #008000;">array(1) { [0]=&gt; string(3) "two" }</span><span style="color: #008000;"><br /></span><span style="color: #008080;">print_r</span>(<span style="color: #800080;">$redis</span>-&gt;keys('*')); <span style="color: #008000;">//</span><span style="color: #008000;">Array ( [0] =&gt; four [1] =&gt; three [2] =&gt; two [3] =&gt; one )</span></pre>
</div>
<p><span style="font-size: 18pt;"><strong>&nbsp;</strong></span></p>
<p><span style="font-size: 18pt;"><strong><a name="key_RANDOMKEY"></a>RANDOMKEY</strong></span></p>
<p>从当前数据库中随机返回(不删除)一个<tt class="docutils literal"><span class="pre">key</span></tt>。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">当数据库不为空时，返回一个<tt class="docutils literal"><span class="pre">key</span></tt>。</div>
<div class="line">当数据库为空时，返回<tt class="docutils literal"><span class="pre">nil。</span></tt></div>
</div>
</dd></dl>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">RANDOMKEY</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;FLUSHALL();<br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况1：数据库不为空</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$array_mset_randomkey</span>=<span style="color: #0000ff;">array</span>('fruit'=&gt;'apple',<br />                'drink'=&gt;'beer',<br />                'food'=&gt;'cookis');<br /><span style="color: #800080;">$redis</span>-&gt;mset(<span style="color: #800080;">$array_mset_randomkey</span>);<br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;randomkey(); <br /><span style="color: #008080;">print_r</span>(<span style="color: #800080;">$redis</span>-&gt;keys('*')); <span style="color: #008000;">#</span><span style="color: #008000;"> 查看数据库内所有key，证明RANDOMKEY并不删除key//Array ( [0] =&gt; food [1] =&gt; drink [2] =&gt; fruit )</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：数据库为空</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;flushdb();  <span style="color: #008000;">#</span><span style="color: #008000;"> 删除当前数据库所有key</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt; randomkey()); <span style="color: #008000;">//</span><span style="color: #008000;">bool(false)</span></pre>
</div>
<p>&nbsp;</p>
<dl class="function"><dt><tt class="descname"><strong><a name="key_TTL"></a><span style="font-size: 18pt;">TTL</span></strong><br />TTL key</tt></dt></dl>
<p>返回给定<tt class="docutils literal"><span class="pre">key</span></tt>的剩余生存时间(time to live)(以秒为单位)。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">key</span></tt>的剩余生存时间(以秒为单位)。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>不存在或没有设置生存时间时，返回<tt class="docutils literal"><span class="pre">-1</span></tt>&nbsp;。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">TTL</span><span style="color: #008000;"><br />#</span><span style="color: #008000;"> 情况1：带TTL的key</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;flushdb();<br /><span style="color: #008000;">//</span><span style="color: #008000;">$redis-&gt;set('name','ikodota'); # 设置一个key</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;expire('name',30);  <span style="color: #008000;">#</span><span style="color: #008000;"> 设置生存时间为30秒 //return (integer) 1</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;get('name'); <span style="color: #008000;">//</span><span style="color: #008000;">return ikodota</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;ttl('name'); <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 25<br /><br />//echo $redis-&gt;ttl('name');  # 30秒过去，name过期 //(integer) -1</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;get('name')); <span style="color: #008000;">#</span><span style="color: #008000;"> 过期的key将被删除 //return bool(false);</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：不带TTL的key</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;set('site','wikipedia.org');<span style="color: #008000;">//</span><span style="color: #008000;">OK</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;ttl('site'));<span style="color: #008000;">//</span><span style="color: #008000;">int(-1)</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况3：不存在的key</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;EXISTS('not_exists_key');<span style="color: #008000;">//</span><span style="color: #008000;">int(0)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;TTL('not_exists_key'));<span style="color: #008000;">//</span><span style="color: #008000;">int(-1)</span></pre>
</div>
<p><span style="color: #ff0000;">&nbsp;</span></p>
<dl class="function"><dt><strong><tt class="descname"><a name="key_EXISTS"></a><span style="font-size: 18pt;">EXISTS</span></tt></strong></dt><dt><tt class="descname">EXISTS key</tt></dt></dl>
<p>检查给定<tt class="docutils literal"><span class="pre">key</span></tt>是否存在。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>若<tt class="docutils literal"><span class="pre">key</span></tt>存在，返回<tt class="docutils literal"><span class="pre">1</span></tt>，否则返回<tt class="docutils literal"><span class="pre">0</span></tt>。</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">EXISTS</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;EXISTS&lt;br&gt;';<br /><span style="color: #800080;">$redis</span>-&gt;set('db',"redis"); <span style="color: #008000;">//</span><span style="color: #008000;">bool(true) </span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;exists('db'));  <span style="color: #008000;">#</span><span style="color: #008000;"> key存在 //bool(true) </span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;del('db');   <span style="color: #008000;">#</span><span style="color: #008000;"> 删除key //int(1)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;exists('db'))  <span style="color: #008000;">#</span><span style="color: #008000;"> key不存在 //bool(false)</span></pre>
</div>
<p><span style="color: #ff0000;">&nbsp;</span></p>
<p><strong><a name="key_move"></a><span style="font-size: 18pt;">MOVE</span></strong><br />MOVE key db</p>
<p>将当前数据库(默认为<tt class="docutils literal"><span class="pre">0</span></tt>)的<tt class="docutils literal"><span class="pre">key</span></tt>移动到给定的数据库<tt class="docutils literal"><span class="pre">db</span></tt>当中。</p>
<p>如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定<tt class="docutils literal"><span class="pre">key</span></tt>，或者<tt class="docutils literal"><span class="pre">key</span></tt>不存在于当前数据库，那么<tt class="docutils literal"><span class="pre">MOVE</span></tt>没有任何效果。</p>
<p>因此，也可以利用这一特性，将<a class="reference internal" href="#key_move">MOVE</a>当作锁(locking)原语。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>移动成功返回<tt class="docutils literal"><span class="pre">1</span></tt>，失败则返回<tt class="docutils literal"><span class="pre">0</span></tt>。</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">MOVE</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;MOVE&lt;br&gt;';<br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况1： key存在于当前数据库</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SELECT(0);  <span style="color: #008000;">#</span><span style="color: #008000;"> redis默认使用数据库0，为了清晰起见，这里再显式指定一次。//OK</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('song',"secret base - Zone"); <span style="color: #008000;">//</span><span style="color: #008000;">OK</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span> (<span style="color: #800080;">$redis</span>-&gt;MOVE('song',1));  <span style="color: #008000;">#</span><span style="color: #008000;"> 将song移动到数据库1 //bool(true)</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：当key不存在的时候</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SELECT(1);<br /><span style="color: #008080;">var_dump</span> (<span style="color: #800080;">$redis</span>-&gt;EXISTS('fake_key'));<span style="color: #008000;">//</span><span style="color: #008000;">bool(false);</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;MOVE('fake_key', 0));  <span style="color: #008000;">#</span><span style="color: #008000;"> 试图从数据库1移动一个不存在的key到数据库0，失败) //bool(false)</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;SELECT(0); <span style="color: #008000;">#</span><span style="color: #008000;"> 使用数据库0</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;EXISTS('fake_key'));  <span style="color: #008000;">#</span><span style="color: #008000;"> 证实fake_key不存在 //bool(false)</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况3：当源数据库和目标数据库有相同的key时</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;SELECT(0);  <span style="color: #008000;">#</span><span style="color: #008000;"> 使用数据库0</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('favorite_fruit',"banana");<br /><br /><span style="color: #800080;">$redis</span>-&gt;SELECT(1);  <span style="color: #008000;">#</span><span style="color: #008000;"> 使用数据库1</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('favorite_fruit',"apple");<br /><br /><span style="color: #800080;">$redis</span>-&gt;SELECT(0);  <span style="color: #008000;">#</span><span style="color: #008000;"> 使用数据库0，并试图将favorite_fruit移动到数据库1</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;MOVE('favorite_fruit',1));  <span style="color: #008000;">#</span><span style="color: #008000;"> 因为两个数据库有相同的key，MOVE失败 //return bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GET('favorite_fruit');  <span style="color: #008000;">#</span><span style="color: #008000;"> 数据库0的favorite_fruit没变 //return banana</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;SELECT(1);<br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GET('favorite_fruit');   <span style="color: #008000;">#</span><span style="color: #008000;"> 数据库1的favorite_fruit也是 //return apple</span></pre>
</div>
<p><strong>&nbsp;</strong></p>
<p><strong><a name="key_RENAME"></a>RENAME</strong>&nbsp;</p>
<dl class="function"><dt><tt class="descname">RENAME key newkey</tt></dt><dd></dd></dl>
<p>将<tt class="docutils literal"><span class="pre">key</span></tt>改名为<tt class="docutils literal"><span class="pre">newkey</span></tt>。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>和<tt class="docutils literal"><span class="pre">newkey</span></tt>相同或者<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，返回一个错误。</p>
<p>当<tt class="docutils literal"><span class="pre">newkey</span></tt>已经存在时，<a class="reference internal" href="#key_RENAME">RENAME</a>命令将覆盖旧值。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>改名成功时提示<tt class="docutils literal"><span class="pre">OK</span></tt>，失败时候返回一个错误。</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">RENAME</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;RENAME&lt;br&gt;';<br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况1：key存在且newkey不存在</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('message',"hello world");<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">RENAME</span>('message','greeting'));  <span style="color: #008000;">//</span><span style="color: #008000;">bool(true)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;EXISTS('message'));  <span style="color: #008000;">#</span><span style="color: #008000;"> message不复存在 //bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;EXISTS('greeting'));   <span style="color: #008000;">#</span><span style="color: #008000;"> greeting取而代之 //bool(true)</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：当key不存在时，返回错误 ,php返回false;</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">RENAME</span>('fake_key','never_exists'));  <span style="color: #008000;">//</span><span style="color: #008000;">bool(false)</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况3：newkey已存在时，RENAME会覆盖旧newkey</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('pc',"lenovo");<br /><span style="color: #800080;">$redis</span>-&gt;SET('personal_computer',"dell"); <br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">RENAME</span>('pc','personal_computer')); <span style="color: #008000;">//</span><span style="color: #008000;">bool(true)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GET('pc')); <span style="color: #008000;">//</span><span style="color: #008000;">(nil)   bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GET('personal_computer'));  <span style="color: #008000;">#</span><span style="color: #008000;"> dell&ldquo;没有&rdquo;了 //string(6) "lenovo"</span></pre>
</div>
<p>&nbsp;</p>
<dl class="function"><dt><strong><tt class="descname"><a name="key_RENAMENX"></a><span style="font-size: 18pt;">RENAMENX&nbsp;</span></tt></strong></dt><dt></dt></dl><dl class="function"><dt><tt class="descname">RENAMENX key newkey</tt></dt><dd></dd></dl>
<p>当且仅当<tt class="docutils literal"><span class="pre">newkey</span></tt>不存在时，将<tt class="docutils literal"><span class="pre">key</span></tt>改为<tt class="docutils literal"><span class="pre">newkey</span></tt>。</p>
<p>出错的情况和<a class="reference internal" href="#key_RENAME">RENAME</a>一样(<tt class="docutils literal"><span class="pre">key</span></tt>不存在时报错)。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">修改成功时，返回<tt class="docutils literal"><span class="pre">1</span></tt>。</div>
<div class="line">如果<tt class="docutils literal"><span class="pre">newkey</span></tt>已经存在，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">RENAMENX</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;RENAMENX&lt;br&gt;';<br /><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况1：newkey不存在，成功</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('player',"MPlyaer");<br /><span style="color: #800080;">$redis</span>-&gt;EXISTS('best_player'); <span style="color: #008000;">//</span><span style="color: #008000;">int(0)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;RENAMENX('player','best_player')); <span style="color: #008000;">//</span><span style="color: #008000;"> bool(true) </span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：newkey存在时，失败</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('animal',"bear");<br /><span style="color: #800080;">$redis</span>-&gt;SET('favorite_animal', "butterfly");<br /><br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;RENAMENX('animal', 'favorite_animal'));<span style="color: #008000;">//</span><span style="color: #008000;"> bool(false)</span><span style="color: #008000;"><br /></span><br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;get('animal')); <span style="color: #008000;">//</span><span style="color: #008000;">string(4) "bear"</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;get('favorite_animal')); <span style="color: #008000;">//</span><span style="color: #008000;">string(9) "butterfly"</span></pre>
</div>
<dl class="function"><dt><br /><br /></dt><dt></dt></dl><dl class="function"><dt><strong><tt class="descname"><a name="key_TYPE"></a><span style="font-size: 18pt;">TYPE</span></tt></strong></dt><dt><tt>TYPE key</tt></dt></dl>
<p>返回<tt class="docutils literal"><span class="pre">key</span></tt>所储存的值的类型。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">none</span></tt>(key不存在) int(0)</div>
<div class="line"><tt class="docutils literal"><span class="pre">string</span></tt>(字符串) int(1)</div>
<div class="line"><tt class="docutils literal"><span class="pre">list</span></tt>(列表) int(3)</div>
<div class="line"><tt class="docutils literal"><span class="pre">set</span></tt>(集合) int(2)</div>
<div class="line"><tt class="docutils literal"><span class="pre">zset</span></tt>(有序集) int(4)</div>
<div class="line"><tt class="docutils literal"><span class="pre">hash</span></tt>(哈希表) int(5)</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">TYPE</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;flushALL();<br /><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;TYPE&lt;br&gt;';<br /><br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;TYPE('fake_key')); <span style="color: #008000;">//</span><span style="color: #008000;">none /int(0)</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;SET('weather',"sunny");  <span style="color: #008000;">#</span><span style="color: #008000;"> 构建一个字符串</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;TYPE('weather'));<span style="color: #008000;">//</span><span style="color: #008000;">string / int(1)</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;SADD('pat',"dog");  <span style="color: #008000;">#</span><span style="color: #008000;"> 构建一个集合</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;TYPE('pat')); <span style="color: #008000;">//</span><span style="color: #008000;">set /int(2)</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;LPUSH('book_list',"programming in scala");  <span style="color: #008000;">#</span><span style="color: #008000;"> 构建一个列表</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;TYPE('book_list'));<span style="color: #008000;">//</span><span style="color: #008000;">list / int(3) </span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;ZADD('pats',1,'cat');  <span style="color: #008000;">#</span><span style="color: #008000;"> 构建一个zset (sorted set) // int(1)</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;ZADD('pats',2,'dog');<br /><span style="color: #800080;">$redis</span>-&gt;ZADD('pats',3,'pig');<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;zRange('pats',0,-1)); <span style="color: #008000;">//</span><span style="color: #008000;"> array(3) { [0]=&gt; string(3) "cat" [1]=&gt; string(3) "dog" [2]=&gt; string(3) "pig" }</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;TYPE('pats')); <span style="color: #008000;">//</span><span style="color: #008000;">zset / int(4)</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;HSET('website','google','www.g.cn');   <span style="color: #008000;">#</span><span style="color: #008000;"> 一个新域</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;HGET('website','google')); <span style="color: #008000;">//</span><span style="color: #008000;">string(8) "www.g.cn"</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;TYPE('website')); <span style="color: #008000;">//</span><span style="color: #008000;">hash /int(5)</span></pre>
</div>
<p><strong><a name="key_EXPIRE"></a><span style="font-size: 18pt;">EXPIRE</span></strong></p>
<p>EXPIRE key seconds<span style="color: #ff0000;"><br /></span></p>
<p>为给定<tt class="docutils literal"><span class="pre">key</span></tt>设置生存时间。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>过期时，它会被自动删除。</p>
<p>在Redis中，带有生存时间的<tt class="docutils literal"><span class="pre">key</span></tt>被称作&ldquo;易失的&rdquo;(volatile)。</p>
<p>&nbsp;</p>
<div class="line-block">
<div class="line">在低于2.1.3版本的Redis中，已存在的生存时间不可覆盖。</div>
<div class="line">从2.1.3版本开始，<tt class="docutils literal"><span class="pre">key</span></tt>的生存时间可以被更新，也可以被<a class="reference internal" href="#key_PERSIST">PERSIST</a>命令移除。(详情参见&nbsp;<a class="reference external" href="http://redis.io/topics/expire">http://redis.io/topics/expire</a>)。</div>
</div>
<p>&nbsp;</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">设置成功返回<tt class="docutils literal"><span class="pre">1</span></tt>。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>不存在或者不能为<tt class="docutils literal"><span class="pre">key</span></tt>设置生存时间时(比如在低于2.1.3中你尝试更新<tt class="docutils literal"><span class="pre">key</span></tt>的生存时间)，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">EXPIRE</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;select(7);<br /><span style="color: #008000;">//</span><span style="color: #008000;">$redis-&gt;flushdb();</span><span style="color: #008000;"><br /></span><br /><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;EXPIRE&lt;br&gt;';<br /><span style="color: #800080;">$redis</span>-&gt;SET('cache_page',"www.cnblogs.com/ikodota");<br /><span style="color: #800080;">$redis</span>-&gt;EXPIRE('cache_page', 30);  <span style="color: #008000;">#</span><span style="color: #008000;"> 设置30秒后过期</span><span style="color: #008000;"><br /></span><span style="color: #008080;">sleep</span>(6);<br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;TTL('cache_page').'&lt;br&gt;';   <span style="color: #008000;">#</span><span style="color: #008000;"> 查看给定key的剩余生存时间 //(integer) 24</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;EXPIRE('cache_page', 3000);  <span style="color: #008000;">#</span><span style="color: #008000;"> 更新生存时间，3000秒</span><span style="color: #008000;"><br /></span><span style="color: #008080;">sleep</span>(4);<br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;TTL('cache_page').'&lt;br&gt;';   <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 2996</span></pre>
</div>
<p><span style="color: #ff0000;">&nbsp;</span></p>
<p>&nbsp;</p>
<dl class="function"><dt><strong><tt class="descname"><a name="key_EXPIREAT"></a><span style="font-size: 18pt;">EXPIREAT&nbsp;</span></tt></strong></dt><dt><tt class="descname">EXPIREAT key timestamp</tt></dt></dl>
<p><a class="reference internal" href="#key_EXPIREAT">EXPIREAT</a>的作用和<a class="reference internal" href="#key_EXPIRE">EXPIRE</a>一样，都用于为<tt class="docutils literal"><span class="pre">key</span></tt>设置生存时间。</p>
<p>不同在于<a class="reference internal" href="#key_EXPIREAT">EXPIREAT</a>命令接受的时间参数是<em>UNIX时间戳</em>(unix timestamp)。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">如果生存时间设置成功，返回<tt class="docutils literal"><span class="pre">1</span></tt>。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>不存在或没办法设置生存时间，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">EXPIREAT</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;EXPIREAT&lt;br&gt;';<br /><span style="color: #800080;">$redis</span>-&gt;SET('cache','www.google.com');<br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;EXPIREAT('cache','1355292000'); <span style="color: #008000;">#</span><span style="color: #008000;"> 这个key将在2012.12.12过期</span><span style="color: #008000;"><br /></span><br /><span style="color: #0000ff;">echo</span> (<span style="color: #800080;">$redis</span>-&gt;TTL('cache')); <span style="color: #008000;">//</span><span style="color: #008000;">return 124345085</span></pre>
</div>
<p><span style="color: #ff0000;">&nbsp;</span></p>
<dl class="function"><dt><strong><tt class="descname"><a name="key_OBJECT"></a><span style="font-size: 18pt;">OBJECT&nbsp;</span></tt></strong></dt><dt><tt class="descname">OBJECT subcommand [arguments [arguments]]</tt></dt></dl>
<p><a class="reference internal" href="#key_OBJECT">OBJECT</a>命令允许从内部察看给定<tt class="docutils literal"><span class="pre">key</span></tt>的Redis对象。</p>
<div class="line-block">
<div class="line">它通常用在除错(debugging)或者了解为了节省空间而对<tt class="docutils literal"><span class="pre">key</span></tt>使用特殊编码的情况。</div>
<div class="line">当将Redis用作缓存程序时，你也可以通过<a class="reference internal" href="#key_OBJECT">OBJECT</a>命令中的信息，决定<tt class="docutils literal"><span class="pre">key</span></tt>的驱逐策略(eviction policies)。</div>
</div>
<p>OBJECT命令有多个子命令：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">OBJECT</span>&nbsp;<span class="pre">REFCOUNT</span>&nbsp;<span class="pre">&lt;key&gt;</span></tt>返回给定<tt class="docutils literal"><span class="pre">key</span></tt>引用所储存的值的次数。此命令主要用于除错。</li>
<li><tt class="docutils literal"><span class="pre">OBJECT</span>&nbsp;<span class="pre">ENCODING</span>&nbsp;<span class="pre">&lt;key&gt;</span></tt>返回给定<tt class="docutils literal"><span class="pre">key</span></tt>锁储存的值所使用的内部表示(representation)。</li>
<li><tt class="docutils literal"><span class="pre">OBJECT</span>&nbsp;<span class="pre">IDLETIME</span>&nbsp;<span class="pre">&lt;key&gt;</span></tt>返回给定<tt class="docutils literal"><span class="pre">key</span></tt>自储存以来的空转时间(idle， 没有被读取也没有被写入)，以秒为单位。</li>
</ul>
<div class="line-block">
<div class="line">对象可以以多种方式编码：</div>
</div>
<ul class="simple">
<li>字符串可以被编码为<tt class="docutils literal"><span class="pre">raw</span></tt>(一般字符串)或<tt class="docutils literal"><span class="pre">int</span></tt>(用字符串表示64位数字是为了节约空间)。</li>
<li>列表可以被编码为<tt class="docutils literal"><span class="pre">ziplist</span></tt>或<tt class="docutils literal"><span class="pre">linkedlist</span></tt>。<tt class="docutils literal"><span class="pre">ziplist</span></tt>是为节约大小较小的列表空间而作的特殊表示。</li>
<li>集合可以被编码为<tt class="docutils literal"><span class="pre">intset</span></tt>或者<tt class="docutils literal"><span class="pre">hashtable</span></tt>。<tt class="docutils literal"><span class="pre">intset</span></tt>是只储存数字的小集合的特殊表示。</li>
<li>哈希表可以编码为<tt class="docutils literal"><span class="pre">zipmap</span></tt>或者<tt class="docutils literal"><span class="pre">hashtable</span></tt>。<tt class="docutils literal"><span class="pre">zipmap</span></tt>是小哈希表的特殊表示。</li>
<li>有序集合可以被编码为<tt class="docutils literal"><span class="pre">ziplist</span></tt>或者<tt class="docutils literal"><span class="pre">skiplist</span></tt>格式。<tt class="docutils literal"><span class="pre">ziplist</span></tt>用于表示小的有序集合，而<tt class="docutils literal"><span class="pre">skiplist</span></tt>则用于表示任何大小的有序集合。</li>
</ul>
<div class="line-block">
<div class="line">假如你做了什么让Redis没办法再使用节省空间的编码时(比如将一个只有1个元素的集合扩展为一个有100万个元素的集合)，特殊编码类型(specially encoded types)会自动转换成通用类型(general type)。</div>
</div>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">REFCOUNT</span></tt>和<tt class="docutils literal"><span class="pre">IDLETIME</span></tt>返回数字。</div>
<div class="line"><tt class="docutils literal"><span class="pre">ENCODING</span></tt>返回相应的编码类型。</div>
</div>
</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">OBJECT</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;select(8);<br /><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;OBJECT&lt;br&gt;';<br /><span style="color: #800080;">$redis</span>-&gt;SET('game',"WOW");  <span style="color: #008000;">#</span><span style="color: #008000;"> 设置一个字符串</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;<span style="color: #0000ff;">OBJECT</span>('REFCOUNT','game');  <span style="color: #008000;">#</span><span style="color: #008000;"> 只有一个引用<br /><br />//sleep(5);</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;<span style="color: #0000ff;">OBJECT</span>('IDLETIME','game');  <span style="color: #008000;">#</span><span style="color: #008000;"> 等待一阵。。。然后查看空转时间 //(integer) 10<br />//echo $redis-&gt;GET('game');  # 提取game， 让它处于活跃(active)状态  //return WOW<br />//echo $redis-&gt;OBJECT('IDLETIME','game');  # 不再处于空转 //(integer) 0</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #0000ff;">OBJECT</span>('ENCODING','game'));  <span style="color: #008000;">#</span><span style="color: #008000;"> 字符串的编码方式 //string(3) "raw"</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('phone',15820123123);  <span style="color: #008000;">#</span><span style="color: #008000;"> 大的数字也被编码为字符串</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #0000ff;">OBJECT</span>('ENCODING','phone')); <span style="color: #008000;">//</span><span style="color: #008000;">string(3) "raw"</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('age',20);  <span style="color: #008000;">#</span><span style="color: #008000;"> 短数字被编码为int</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #0000ff;">OBJECT</span>('ENCODING','age')); <span style="color: #008000;">//</span><span style="color: #008000;">string(3) "int"</span></pre>
</div>
<p><span style="color: #ff0000;">&nbsp;</span></p>
<dl class="function"><dt><strong><tt class="descname"><a name="key_PERSIST"></a><span style="font-size: 18pt;">PERSIST&nbsp;</span></tt></strong></dt><dt><tt class="descname">PERSIST key</tt></dt><dd></dd></dl>
<p>&nbsp;</p>
<p>移除给定<tt class="docutils literal"><span class="pre">key</span></tt>的生存时间。</p>
<p>&nbsp;</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">当生存时间移除成功时，返回<tt class="docutils literal"><span class="pre">1</span></tt>.</div>
<div class="line">如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在或<tt class="docutils literal"><span class="pre">key</span></tt>没有设置生存时间，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">PERSIST</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;PERSIST&lt;br&gt;';<br /><span style="color: #800080;">$redis</span>-&gt;SET('time_to_say_goodbye',"886...");<br /><span style="color: #800080;">$redis</span>-&gt;EXPIRE('time_to_say_goodbye', 300);<br /><span style="color: #008080;">sleep</span>(3);<br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;TTL('time_to_say_goodbye'); <span style="color: #008000;">#</span><span style="color: #008000;"> (int) 297</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;';<br /><br /><span style="color: #800080;">$redis</span>-&gt;PERSIST('time_to_say_goodbye');  <span style="color: #008000;">#</span><span style="color: #008000;"> 移除生存时间</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;TTL('time_to_say_goodbye');  <span style="color: #008000;">#</span><span style="color: #008000;"> 移除成功  //int(-1)</span></pre>
</div>
<p><span style="color: #ff0000;"><br /><strong><a name="key_SORT"></a><span style="font-size: 18pt;">SORT</span></strong></span></p>
<p>&nbsp;</p>
<dl class="function"><dt><strong><tt class="descname">SORT key [<span style="color: #ff0000;">BY pattern</span>] [<span style="color: #000080;">LIMIT offset count</span>] [<span style="color: #993366;">GET pattern [GET pattern ...]</span>] [<span style="color: #008000;">ASC | DESC</span>] [<span style="color: #ff00ff;">ALPHA</span>] [<span style="color: #0000ff;">STORE destination</span>]</tt></strong></dt><dd></dd></dl>
<p>排序，分页等<br />参数</p>
<p>array(<br />&lsquo;by&rsquo; =&gt; &lsquo;some_pattern_*&rsquo;,<br />&lsquo;limit&rsquo; =&gt; array(0, 1),<br />&lsquo;get&rsquo; =&gt; &lsquo;some_other_pattern_*&rsquo; or an array of patterns,<br />&lsquo;sort&rsquo; =&gt; &lsquo;asc&rsquo; or &lsquo;desc&rsquo;,<br />&lsquo;alpha&rsquo; =&gt; TRUE,<br />&lsquo;store&rsquo; =&gt; &lsquo;external-key&rsquo;<br />)</p>
<p>返回或保存给定列表、集合、有序集合<tt class="docutils literal"><span class="pre">key</span></tt>中经过排序的元素。</p>
<p>排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。</p>
<p>&nbsp;</p>
<p><strong>一般SORT用法</strong></p>
<p>最简单的<a class="reference internal" href="#key_SORT">SORT</a>使用方法是<tt class="docutils literal"><span class="pre">SORT</span>&nbsp;<span class="pre">key</span></tt>。</p>
<p>假设<tt class="docutils literal"><span class="pre">today_cost</span></tt>是一个保存数字的列表，<a class="reference internal" href="#key_SORT">SORT</a>命令默认会返回该列表值的递增(从小到大)排序结果。</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 将数据一一加入到列表中</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('today_cost', 30);<br /><span style="color: #800080;">$redis</span>-&gt;LPUSH('today_cost', 1.5);<br /><span style="color: #800080;">$redis</span>-&gt;LPUSH('today_cost', 10);<br /><span style="color: #800080;">$redis</span>-&gt;LPUSH('today_cost', 8);<br /><span style="color: #008000;">#</span><span style="color: #008000;"> 排序</span><br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('today_cost')); <span style="color: #008000;">//</span><span style="color: #008000;">array(4) { [0]=&gt; string(3) "1.5" [1]=&gt; string(1) "8" [2]=&gt; string(2) "10" [3]=&gt; string(2) "30" }</span></pre>
</div>
<p>当数据集中保存的是字符串值时，你可以用<tt>ALPHA</tt>修饰符(modifier)进行排序。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 将数据一一加入到列表中</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('website', "www.reddit.com");<br /><span style="color: #800080;">$redis</span>-&gt;LPUSH('website', "www.slashdot.com");<br /><span style="color: #800080;">$redis</span>-&gt;LPUSH('website', "www.infoq.com");<br /><span style="color: #008000;">#</span><span style="color: #008000;"> 默认排序</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('website'));<span style="color: #008000;">//</span><span style="color: #008000;">array(3) { [0]=&gt; string(13) "www.infoq.com" [1]=&gt; string(16) "www.slashdot.com" [2]=&gt; string(14) "www.reddit.com" }</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 按字符排序 ALPHA=true</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('website', <span style="color: #0000ff;">array</span>('ALPHA'=&gt;<span style="color: #0000ff;">TRUE</span>))); <span style="color: #008000;">//</span><span style="color: #008000;">array(3) { [0]=&gt; string(13) "www.infoq.com" [1]=&gt; string(14) "www.reddit.com" [2]=&gt; string(16) "www.slashdot.com" }</span></pre>
</div>
<p>如果你正确设置了<tt class="docutils literal"><span class="pre">!LC_COLLATE</span></tt>环境变量的话，Redis能识别<tt class="docutils literal"><span class="pre">UTF-8</span></tt>编码。</p>
<div class="line-block">
<div class="line">排序之后返回的元素数量可以通过<tt class="docutils literal"><span class="pre">LIMIT</span></tt>修饰符进行限制。</div>
<div class="line"><tt class="docutils literal"><span class="pre">LIMIT</span></tt>修饰符接受两个参数：<tt class="docutils literal"><span class="pre">offset</span></tt>和<tt class="docutils literal"><span class="pre">count</span></tt>。</div>
<div class="line"><tt class="docutils literal"><span class="pre">offset</span></tt>指定要跳过的元素数量，<tt class="docutils literal"><span class="pre">count</span></tt>指定跳过<tt class="docutils literal"><span class="pre">offset</span></tt>个指定的元素之后，要返回多少个对象。</div>
</div>
<p>以下例子返回排序结果的前5个对象(<tt class="docutils literal"><span class="pre">offset</span></tt>为<tt class="docutils literal"><span class="pre">0</span></tt>表示没有元素被跳过)。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 将数据一一加入到列表中</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('rank', 30); <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 1</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('rank', 56); <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 2</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('rank', 42); <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 3</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('rank', 22); <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 4</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('rank', 0);  <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 5</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('rank', 11); <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 6</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('rank', 32); <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 7</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('rank', 67); <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 8</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('rank', 50); <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 9</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('rank', 44); <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 10</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('rank', 55); <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 11</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 排序</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis_sort_option</span>=<span style="color: #0000ff;">array</span>('LIMIT'=&gt;<span style="color: #0000ff;">array</span>(0,5));<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('rank',<span style="color: #800080;">$redis_sort_option</span>));   <span style="color: #008000;">#</span><span style="color: #008000;"> 返回排名前五的元素 // array(5) { [0]=&gt; string(1) "0" [1]=&gt; string(2) "11" [2]=&gt; string(2) "22" [3]=&gt; string(2) "30" [4]=&gt; string(2) "32" }</span></pre>
</div>
<p>修饰符可以组合使用。以下例子返回降序(从大到小)的前5个对象。</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">$redis_sort_option</span>=<span style="color: #0000ff;">array</span>(<br />            'LIMIT'=&gt;<span style="color: #0000ff;">array</span>(0,5),<br />            'SORT'=&gt;'DESC'<br />            );<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('rank',<span style="color: #800080;">$redis_sort_option</span>)); <span style="color: #008000;">//</span><span style="color: #008000;">array(5) { [0]=&gt; string(2) "67" [1]=&gt; string(2) "56" [2]=&gt; string(2) "55" [3]=&gt; string(2) "50" [4]=&gt; string(2) "44" }</span></pre>
</div>
<p>&nbsp;</p>
<p>使用外部key进行排序</p>
<p>有时候你会希望使用外部的key作为权重来比较元素，代替默认的对比方法。</p>
<p>假设现在有用户(user)数据如下：</p>
<p>id　　　 &nbsp;name　　　　level<br />-------------------------------<br />1　　　　admin　　　 &nbsp;9999<br />2　　　　huangz　　　10<br />59230 　jack 　　　 &nbsp; &nbsp;3<br />222 　　&nbsp;hacker 　　 &nbsp;&nbsp;9999</p>
<p>id数据保存在key名为user_id的列表中。<br />name数据保存在key名为user_name_{id}的列表中<br />level数据保存在user_level_{id}的key中。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 先将要使用的数据加入到数据库中</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> admin</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('user_id', 1);<span style="color: #008000;">//</span><span style="color: #008000;">(integer) 1</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('user_name_1', 'admin');<br /><span style="color: #800080;">$redis</span>-&gt;SET('user_level_1',9999);<br /><br /><span style="color: #008000;">#</span><span style="color: #008000;"> huangz</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('user_id', 2);<span style="color: #008000;">//</span><span style="color: #008000;">(integer) 2</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('user_name_2', 'huangz');<br /><span style="color: #800080;">$redis</span>-&gt;SET('user_level_2', 10);<br /><br /><span style="color: #008000;">#</span><span style="color: #008000;"> jack</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('user_id', 59230);<span style="color: #008000;">//</span><span style="color: #008000;">(integer) 3</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('user_name_59230','jack');<br /><span style="color: #800080;">$redis</span>-&gt;SET('user_level_59230', 3);<br /><br /><span style="color: #008000;">#</span><span style="color: #008000;"> hacker</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('user_id', 222);  <span style="color: #008000;">//</span><span style="color: #008000;">(integer) 4</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('user_name_222', 'hacker');<br /><span style="color: #800080;">$redis</span>-&gt;SET('user_level_222', 9999);<br /><span style="color: #008000;"><br /></span></pre>
</div>
<p>&nbsp;</p>
<p>如果希望按<tt class="docutils literal"><span class="pre">level</span></tt>从大到小排序<tt class="docutils literal"><span class="pre">user_id</span></tt>，可以使用以下命令：</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">$redis_sort_option</span>=<span style="color: #0000ff;">array</span>('BY'=&gt;'user_level_*',<br />            'SORT'=&gt;'DESC'<br />            );<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('user_id',<span style="color: #800080;">$redis_sort_option</span>)); <span style="color: #008000;">//</span><span style="color: #008000;">array(4) { [0]=&gt; string(3) "222" [1]=&gt; string(1) "1" [2]=&gt; string(1) "2" [3]=&gt; string(5) "59230" }</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;">---------------------------</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">1) "222"    # hacker</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">2) "1"      # admin</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">3) "2"      # huangz</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">4) "59230"  # jack</span></pre>
</div>
<p>但是有时候只是返回相应的<tt class="docutils literal"><span class="pre">id</span></tt>没有什么用，你可能更希望排序后返回<tt class="docutils literal"><span class="pre">id</span></tt>对应的用户名，这样更友好一点，使用<tt class="docutils literal"><span class="pre">GET</span></tt>选项可以做到这一点：</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">$redis_sort_option</span>=<span style="color: #0000ff;">array</span>('BY'=&gt;'user_level_*',<br />            'SORT'=&gt;'DESC',<br />            'GET'=&gt;'user_name_*'<br />            );<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('user_id', <span style="color: #800080;">$redis_sort_option</span>)); <span style="color: #008000;">//</span><span style="color: #008000;">array(4) { [0]=&gt; string(6) "hacker" [1]=&gt; string(5) "admin" [2]=&gt; string(6) "huangz" [3]=&gt; string(4) "jack" }</span><span><br /></span></pre>
<pre><span style="color: #008000;">#</span><span style="color: #008000;">1) "hacker"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">2) "admin"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">3) "huangz"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">4) "jack"</span></pre>
</div>
<p>可以多次地、有序地使用<tt class="docutils literal"><span class="pre">GET</span></tt>操作来获取更多外部<tt class="docutils literal"><span class="pre">key</span></tt>。</p>
<p>比如你不但希望获取用户名，还希望连用户的密码也一并列出，可以使用以下命令：</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 先添加一些测试数据</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('user_password_222', "hey,im in");<br /><span style="color: #800080;">$redis</span>-&gt;SET('user_password_1', "a_long_long_password");<br /><span style="color: #800080;">$redis</span>-&gt;SET('user_password_2', "nobodyknows");<br /><span style="color: #800080;">$redis</span>-&gt;SET('user_password_59230', "jack201022");<br /><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 获取name和password</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis_sort_option</span>=<span style="color: #0000ff;">array</span>('BY'=&gt;'user_level_*',<br />            'SORT'=&gt;'DESC',<br />            'GET'=&gt;<span style="color: #0000ff;">array</span>('user_name_*','user_password_*')<br />            );<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('user_id',<span style="color: #800080;">$redis_sort_option</span>));<span style="color: #008000;">//</span><span style="color: #008000;">array(8) { [0]=&gt; string(6) "hacker" [1]=&gt; string(9) "hey,im in" [2]=&gt; string(5) "admin" [3]=&gt; string(20) "a_long_long_password" [4]=&gt; string(6) "huangz" [5]=&gt; string(11) "nobodyknows" [6]=&gt; string(4) "jack" [7]=&gt; string(10) "jack201022" }</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;">------------------------------------</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">1) "hacker"       # 用户名</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">2) "hey,im in"    # 密码</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">3) "jack"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">4) "jack201022"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">5) "huangz"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">6) "nobodyknows"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">7) "admin"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">8) "a_long_long_password"</span></pre>
</div>
<pre># 注意GET操作是有序的，GET user_name_* GET user_password_* 和 GET user_password_* GET user_name_*返回的结果位置不同</pre>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 获取name和password 注意GET操作是有序的</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis_sort_option</span>=<span style="color: #0000ff;">array</span>('BY'=&gt;'user_level_*',<br />            'SORT'=&gt;'DESC',<br />            'GET'=&gt;<span style="color: #0000ff;">array</span>('<span style="color: #ff0000;">user_password_*</span>','<span style="color: #ff0000;">user_name_*</span>')<br />            );<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('user_id',<span style="color: #800080;">$redis_sort_option</span>));<span style="color: #008000;">//</span><span style="color: #008000;"> array(8) { [0]=&gt; string(9) "hey,im in" [1]=&gt; string(6) "hacker" [2]=&gt; string(20) "a_long_long_password" [3]=&gt; string(5) "admin" [4]=&gt; string(11) "nobodyknows" [5]=&gt; string(6) "huangz" [6]=&gt; string(10) "jack201022" [7]=&gt; string(4) "jack" }</span></pre>
</div>
<p><tt class="docutils literal"><span class="pre">GET</span></tt>还有一个特殊的规则&mdash;&mdash;<tt class="docutils literal"><span class="pre">"GET</span>&nbsp;<span class="pre">#"</span></tt>，用于获取被排序对象(我们这里的例子是<tt class="docutils literal"><span class="pre">user_id</span></tt>)的当前元素。</p>
<p>比如你希望<tt class="docutils literal"><span class="pre">user_id</span></tt>按<tt class="docutils literal"><span class="pre">level</span></tt>排序，还要列出<tt class="docutils literal"><span class="pre">id</span></tt>、<tt class="docutils literal"><span class="pre">name</span></tt>和<tt class="docutils literal"><span class="pre">password</span></tt>，可以使用以下命令：</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">$redis_sort_option</span>=<span style="color: #0000ff;">array</span>('BY'=&gt;'user_level_*',<br />            'SORT'=&gt;'DESC',<br />            'GET'=&gt;<span style="color: #0000ff;">array</span>('#','user_password_*','user_name_*')<br />            );<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('user_id',<span style="color: #800080;">$redis_sort_option</span>));<span style="color: #008000;">//</span><span style="color: #008000;">array(12) { [0]=&gt; string(3) "222" [1]=&gt; string(9) "hey,im in" [2]=&gt; string(6) "hacker" [3]=&gt; string(1) "1" [4]=&gt; string(20) "a_long_long_password" [5]=&gt; string(5) "admin" [6]=&gt; string(1) "2" [7]=&gt; string(11) "nobodyknows" [8]=&gt; string(6) "huangz" [9]=&gt; string(5) "59230" [10]=&gt; string(10) "jack201022" [11]=&gt; string(4) "jack" }</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;">--------------------------------------------------------------</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">1) "222"          # id</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">2) "hacker"       # name</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">3) "hey,im in"    # password</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">4) "1"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">5) "admin"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">6) "a_long_long_password"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">7) "2"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">8) "huangz"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">9) "nobodyknows"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">10) "59230"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">11) "jack"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">12) "jack201022"</span></pre>
</div>
<p><strong>只获取对象而不排序</strong></p>
<p><tt class="docutils literal"><span class="pre">BY</span></tt>修饰符可以将一个不存在的<tt class="docutils literal"><span class="pre">key</span></tt>当作权重，让<a class="reference internal" href="#key_SORT">SORT</a>跳过排序操作。</p>
<p>该方法用于你希望获取外部对象而又不希望引起排序开销时使用。</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 确保fake_key不存在</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;EXISTS('fake_key');<span style="color: #008000;">//</span><span style="color: #008000;">(integer) 0</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 以fake_key作BY参数，不排序，只GET name 和 GET password</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis_sort_option</span>=<span style="color: #0000ff;">array</span>('BY'=&gt;'fake_key',<br />            'SORT'=&gt;'DESC',<br />            'GET'=&gt;<span style="color: #0000ff;">array</span>('#','user_name_*','user_password_*')<br />            );<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('user_id',<span style="color: #800080;">$redis_sort_option</span>));<span style="color: #008000;">//</span><span style="color: #008000;">array(12) { [0]=&gt; string(3) "222" [1]=&gt; string(6) "hacker" [2]=&gt; string(9) "hey,im in" [3]=&gt; string(5) "59230" [4]=&gt; string(4) "jack" [5]=&gt; string(10) "jack201022" [6]=&gt; string(1) "2" [7]=&gt; string(6) "huangz" [8]=&gt; string(11) "nobodyknows" [9]=&gt; string(1) "1" [10]=&gt; string(5) "admin" [11]=&gt; string(20) "a_long_long_password" }</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;">----------------------------------------------</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">1) "222"        # id</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">2) "hacker"     # user_name</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">3) "hey,im in"  # password</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">4) "59230"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">5) "jack"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">6) "jack201022"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">7) "2"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">8) "huangz"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">9) "nobodyknows"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">10) "1"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">11) "admin"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">12) "a_long_long_password"</span></pre>
</div>
<p><strong>保存排序结果</strong></p>
<p>默认情况下，<a class="reference internal" href="#key_SORT">SORT</a>操作只是简单地返回排序结果，如果你希望保存排序结果，可以给<tt class="docutils literal"><span class="pre">STORE</span></tt>选项指定一个<tt class="docutils literal"><span class="pre">key</span></tt>作为参数，排序结果将以列表的形式被保存到这个<tt class="docutils literal"><span class="pre">key</span></tt>上。(若指定<tt class="docutils literal"><span class="pre">key</span></tt>已存在，则覆盖。)</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">$redis</span>-&gt;EXISTS('user_info_sorted_by_level');  <span style="color: #008000;">#</span><span style="color: #008000;"> 确保指定key不存在   //(integer) 0</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis_sort_option</span>=<span style="color: #0000ff;">array</span>('BY'=&gt;'user_level_*',<br />            'GET'=&gt;<span style="color: #0000ff;">array</span>('#','user_name_*','user_password_*'),<br />            'STORE'=&gt;'user_info_sorted_by_level'<br />            );<br /><br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('user_id',<span style="color: #800080;">$redis_sort_option</span>)); <span style="color: #008000;">//</span><span style="color: #008000;">int(12)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;LRANGE('user_info_sorted_by_level', 0 ,11));  <span style="color: #008000;">#</span><span style="color: #008000;"> 查看排序结果  //array(12) { [0]=&gt; string(5) "59230" [1]=&gt; string(4) "jack" [2]=&gt; string(10) "jack201022" [3]=&gt; string(1) "2" [4]=&gt; string(6) "huangz" [5]=&gt; string(11) "nobodyknows" [6]=&gt; string(3) "222" [7]=&gt; string(6) "hacker" [8]=&gt; string(9) "hey,im in" [9]=&gt; string(1) "1" [10]=&gt; string(5) "admin" [11]=&gt; string(20) "a_long_long_password" }</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;">-----------------------------------------------------------------</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">1) "59230"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">2) "jack"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">3) "jack201022"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">4) "2"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">5) "huangz"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">6) "nobodyknows"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">7) "222"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">8) "hacker"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">9) "hey,im in"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">10) "1"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">11) "admin"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">12) "a_long_long_password"</span></pre>
</div>
<p>一个有趣的用法是将SORT结果保存，用EXPIRE为结果集设置生存时间，这样结果集就成了SORT操作的一个缓存。</p>
<p>这样就不必频繁地调用SORT操作了，只有当结果集过期时，才需要再调用一次SORT操作。</p>
<p>有时候为了正确实现这一用法，你可能需要加锁以避免多个客户端同时进行缓存重建(也就是多个客户端，同一时间进行SORT操作，并保存为结果集)，具体参见SETNX命令。</p>
<p>在GET和BY中使用哈希表</p>
<p>可以使用哈希表特有的语法，在SORT命令中进行GET和BY操作。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 假设现在我们的用户表新增了一个serial项来为作为每个用户的序列号</span><span style="color: #008000;"><br />#</span><span style="color: #008000;"> 序列号以哈希表的形式保存在serial哈希域内。</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis_hash_testdata_array</span>=<span style="color: #0000ff;">array</span>(1=&gt;'23131283',<br />                2=&gt;'23810573',<br />                222=&gt;'502342349',<br />                59230=&gt;'2435829758'<br />                );<br /><br /><span style="color: #800080;">$redis</span>-&gt;HMSET('serial',<span style="color: #800080;">$redis_hash_testdata_array</span>);<br /><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 我们希望以比较serial中的大小来作为排序user_id的方式</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis_sort_option</span>=<span style="color: #0000ff;">array</span>('BY'=&gt;'*-&gt;serial');<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">SORT</span>('user_id', <span style="color: #800080;">$redis_sort_option</span>)); <span style="color: #008000;">//</span><span style="color: #008000;">array(4) { [0]=&gt; string(3) "222" [1]=&gt; string(5) "59230" [2]=&gt; string(1) "2" [3]=&gt; string(1) "1" }</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;">----------------------------------------</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">1) "222"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">2) "59230"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">3) "2"</span><span style="color: #008000;"><br />#</span><span style="color: #008000;">4) "1"</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong>符号<tt class="docutils literal"><span class="pre">"<span style="color: #ff0000;">-&gt;</span>"</span></tt></strong></span>用于分割哈希表的关键字(key name)和索引域(hash field)，格式为<tt class="docutils literal"><span class="pre">"key-&gt;field"</span></tt>。</p>
<p>除此之外，哈希表的<tt class="docutils literal"><span class="pre">BY</span></tt>和<tt class="docutils literal"><span class="pre">GET</span></tt>操作和上面介绍的其他数据结构(列表、集合、有序集合)没有什么不同。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>
<div class="first last line-block">
<div class="line">O(N+M*log(M))，<tt class="docutils literal"><span class="pre">N</span></tt>为要排序的列表或集合内的元素数量，<tt class="docutils literal"><span class="pre">M</span></tt>为要返回的元素数量。</div>
<div class="line">如果只是使用<a class="reference internal" href="#key_SORT">SORT</a>命令的<tt class="docutils literal"><span class="pre">GET</span></tt>选项获取数据而没有进行排序，时间复杂度O(N)。</div>
</div>
</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">没有使用<tt class="docutils literal"><span class="pre">STORE</span></tt>参数，返回列表形式的排序结果。</div>
<div class="line">使用<tt class="docutils literal"><span class="pre">STORE</span></tt>参数，返回排序结果的元素数量。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h1><a name="STRING"></a>字符串(String)</h1>
<p><a name="string_SET"></a><span style="font-size: 18pt;">SET</span></p>
<dl class="function"><dt><tt class="descname">SET key value</tt></dt><dd></dd></dl>
<p>将字符串值<tt class="docutils literal"><span class="pre">value</span></tt>关联到<tt class="docutils literal"><span class="pre">key</span></tt>。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>已经持有其他值，<a class="reference internal" href="#string_SET">SET</a>就覆写旧值，无视类型。</p>
<p><br /><strong>时间复杂度：</strong>O(1)<strong>返回值：</strong>总是返回<tt class="docutils literal"><span class="pre">OK(TRUE)</span></tt>，因为<a class="reference internal" href="#string_SET" data-mce-="">SET</a>不可能失败。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 情况1：对字符串类型的key进行SET</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('apple', 'www.apple.com');<span style="color: #008000;">#</span><span style="color: #008000;">OK  //bool(true)</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;GET('apple');<span style="color: #008000;">//</span><span style="color: #008000;">"www.apple.com"</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：对非字符串类型的key进行SET</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;LPUSH('greet_list', "hello");  <span style="color: #008000;">#</span><span style="color: #008000;"> 建立一个列表 #(integer) 1 //int(1)</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;TYPE('greet_list');<span style="color: #008000;">#</span><span style="color: #008000;">list //int(3)</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;SET('greet_list', "yooooooooooooooooo");   <span style="color: #008000;">#</span><span style="color: #008000;"> 覆盖列表类型 #OK //bool(true)</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;TYPE('greet_list');<span style="color: #008000;">#</span><span style="color: #008000;">string //int(1)</span></pre>
</div>
<p>&nbsp;</p>
</div>
<div id="post_content"><strong><a name="string_SETNX"></a><span style="font-size: 18pt;">SETNX</span></strong></div>
<div><dl class="function"><dt><tt class="descname">SETNX key value</tt></dt><dd></dd></dl>
<p>将<tt class="docutils literal"><span class="pre">key</span></tt>的值设为<tt class="docutils literal"><span class="pre">value</span></tt>，当且仅当<tt class="docutils literal"><span class="pre">key</span></tt>不存在。</p>
<p>若给定的<tt class="docutils literal"><span class="pre">key</span></tt>已经存在，则<a class="reference internal" href="#string_SETNX">SETNX</a>不做任何动作。</p>
<p><a class="reference internal" href="#string_SETNX">SETNX</a>是&rdquo;SET if Not eXists&rdquo;(如果不存在，则SET)的简写。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">设置成功，返回<tt class="docutils literal"><span class="pre">1</span></tt>。</div>
<div class="line">设置失败，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl></div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">SETNX</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;SETNX&lt;br&gt;';<br /><span style="color: #800080;">$redis</span>-&gt;EXISTS('job');  <span style="color: #008000;">#</span><span style="color: #008000;"> job不存在 //bool(false);</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SETNX('job', "programmer");  <span style="color: #008000;">#</span><span style="color: #008000;"> job设置成功 //bool(true)</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SETNX('job', "code-farmer");  <span style="color: #008000;">#</span><span style="color: #008000;"> job设置失败 //bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GET('job');  <span style="color: #008000;">#</span><span style="color: #008000;"> 没有被覆盖 //"programmer"</span></pre>
</div>
<p><strong>设计模式(Design pattern): 将SETNX用于加锁(locking)</strong></p>
<p><a class="reference internal" href="#string_SETNX">SETNX</a>可以用作加锁原语(locking primitive)。比如说，要对关键字(key)<tt class="docutils literal"><span class="pre">foo</span></tt>加锁，客户端可以尝试以下方式：</p>
<p><tt class="docutils literal"><span class="pre">SETNX</span>&nbsp;<span class="pre">lock.foo</span>&nbsp;<span class="pre">&lt;current</span>&nbsp;<span class="pre">Unix</span>&nbsp;<span class="pre">time</span>&nbsp;<span class="pre">+</span>&nbsp;<span class="pre">lock</span>&nbsp;<span class="pre">timeout</span>&nbsp;<span class="pre">+</span>&nbsp;<span class="pre">1&gt;</span></tt></p>
<p>如果<a class="reference internal" href="#string_SETNX">SETNX</a>返回<tt class="docutils literal"><span class="pre">1</span></tt>，说明客户端已经获得了锁，<tt class="docutils literal"><span class="pre">key</span></tt>设置的unix时间则指定了锁失效的时间。之后客户端可以通过<tt class="docutils literal"><span class="pre">DEL</span>&nbsp;<span class="pre">lock.foo</span></tt>来释放锁。</p>
<p>如果<a class="reference internal" href="#string_SETNX">SETNX</a>返回<tt class="docutils literal"><span class="pre">0</span></tt>，说明<tt class="docutils literal"><span class="pre">key</span></tt>已经被其他客户端上锁了。如果锁是非阻塞(non blocking lock)的，我们可以选择返回调用，或者进入一个重试循环，直到成功获得锁或重试超时(timeout)。</p>
<p><strong>处理死锁(deadlock)</strong></p>
<p>上面的锁算法有一个问题：如果因为客户端失败、崩溃或其他原因导致没有办法释放锁的话，怎么办？</p>
<p>这种状况可以通过检测发现&mdash;&mdash;因为上锁的<tt class="docutils literal"><span class="pre">key</span></tt>保存的是unix时间戳，假如<tt class="docutils literal"><span class="pre">key</span></tt>值的时间戳小于当前的时间戳，表示锁已经不再有效。</p>
<p>但是，当有多个客户端同时检测一个锁是否过期并尝试释放它的时候，我们不能简单粗暴地删除死锁的<tt class="docutils literal"><span class="pre">key</span></tt>，再用<a class="reference internal" href="#string_SETNX">SETNX</a>上锁，因为这时竞争条件(race condition)已经形成了：</p>
<ul class="simple">
<li>C1和C2读取<tt class="docutils literal"><span class="pre">lock.foo</span></tt>并检查时间戳，<a class="reference internal" href="#string_SETNX">SETNX</a>都返回<tt class="docutils literal"><span class="pre">0</span></tt>，因为它已经被C3锁上了，但C3在上锁之后就崩溃(crashed)了。</li>
<li>C1向<tt class="docutils literal"><span class="pre">lock.foo</span></tt>发送<a class="reference internal" href="#key_del"><em>DEL</em></a>命令。</li>
<li>C1向<tt class="docutils literal"><span class="pre">lock.foo</span></tt>发送<a class="reference internal" href="#string_SETNX">SETNX</a>并成功。</li>
<li>C2向<tt class="docutils literal"><span class="pre">lock.foo</span></tt>发送<a class="reference internal" href="#key_del"><em>DEL</em></a>命令。</li>
<li>C2向<tt class="docutils literal"><span class="pre">lock.foo</span></tt>发送<a class="reference internal" href="#string_SETNX">SETNX</a>并成功。</li>
<li>出错：因为竞争条件的关系，C1和C2两个都获得了锁。</li>
</ul>
<p>幸好，以下算法可以避免以上问题。来看看我们聪明的C4客户端怎么办：</p>
<ul class="simple">
<li>C4向<tt class="docutils literal"><span class="pre">lock.foo</span></tt>发送<a class="reference internal" href="#string_SETNX">SETNX</a>命令。</li>
<li>因为崩溃掉的C3还锁着<tt class="docutils literal"><span class="pre">lock.foo</span></tt>，所以Redis向C4返回<tt class="docutils literal"><span class="pre">0</span></tt>。</li>
<li>C4向<tt class="docutils literal"><span class="pre">lock.foo</span></tt>发送<a class="reference internal" href="#string_GET">GET</a>命令，查看<tt class="docutils literal"><span class="pre">lock.foo</span></tt>的锁是否过期。如果不，则休眠(sleep)一段时间，并在之后重试。</li>
<li>另一方面，如果<tt class="docutils literal"><span class="pre">lock.foo</span></tt>内的unix时间戳比当前时间戳老，C4执行以下命令：</li>
</ul>
<p><tt class="docutils literal"><span class="pre">GETSET</span>&nbsp;<span class="pre">lock.foo</span>&nbsp;<span class="pre">&lt;current</span>&nbsp;<span class="pre">Unix</span>&nbsp;<span class="pre">timestamp</span>&nbsp;<span class="pre">+</span>&nbsp;<span class="pre">lock</span>&nbsp;<span class="pre">timeout</span>&nbsp;<span class="pre">+</span>&nbsp;<span class="pre">1&gt;</span></tt></p>
<ul class="simple">
<li>因为<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/string.html#getset">GETSET</a>的作用，C4可以检查看<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/string.html#getset">GETSET</a>的返回值，确定<tt class="docutils literal"><span class="pre">lock.foo</span></tt>之前储存的旧值仍是那个过期时间戳，如果是的话，那么C4获得锁。</li>
<li>如果其他客户端，比如C5，比C4更快地执行了<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/string.html#getset">GETSET</a>操作并获得锁，那么C4的<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/string.html#getset">GETSET</a>操作返回的就是一个未过期的时间戳(C5设置的时间戳)。C4只好从第一步开始重试。</li>
</ul>
<div class="line-block">
<div class="line">注意，即便C4的<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/string.html#getset">GETSET</a>操作对<tt class="docutils literal"><span class="pre">key</span></tt>进行了修改，这对未来也没什么影响。</div>
<div class="line">(这里是不是有点问题？C4的确是可以重试，但C5怎么办？它的锁的过期被C4修改了。&mdash;&mdash;译注)</div>
</div>
</div>
<div>
<blockquote>
<p class="first admonition-title">&nbsp;<strong style="color: #ff0000;"><span data-mce-="">警告</span></strong></p>
<p class="last"><span style="color: #ff0000;" data-mce-="">为了让这个加锁算法更健壮，获得锁的客户端应该常常检查过期时间以免锁因诸如<a class="reference internal" href="#key_del"><span style="color: #ff0000;" data-mce-=""><em>DEL</em></span></a>等命令的执行而被意外解开，因为客户端失败的情况非常复杂，不仅仅是崩溃这么简单，还可能是客户端因为某些操作被阻塞了相当长时间，紧接着<a class="reference internal" href="#key_del"><span style="color: #ff0000;" data-mce-=""><em>DEL</em></span></a>命令被尝试执行(但这时锁却在另外的客户端手上)。</span></p>
</blockquote>
</div>
<div>&nbsp;</div>
<div><strong><a name="string_SETEX"></a><span style="font-size: 18pt;">SETEX</span></strong></div>
<div>SETEX key seconds value</div>
<div>
<p>将值<tt class="docutils literal"><span class="pre">value</span></tt>关联到<tt class="docutils literal"><span class="pre">key</span></tt>，并将<tt class="docutils literal"><span class="pre">key</span></tt>的生存时间设为<tt class="docutils literal"><span class="pre">seconds</span></tt>(以秒为单位)。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>&nbsp;已经存在，<a class="reference internal" href="#string_SETEX">SETEX</a>命令将覆写旧值。</p>
<p>这个命令类似于以下两个命令：</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">$redis</span>-&gt;SET('key', 'value');<br /><span style="color: #800080;">$redis</span>-&gt;EXPIRE('key','seconds');  <span style="color: #008000;">#</span><span style="color: #008000;"> 设置生存时间 </span></pre>
</div>
<p>不同之处是，<a class="reference internal" href="#string_SETEX">SETEX</a>是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成，该命令在Redis用作缓存时，非常实用。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">设置成功时返回<tt class="docutils literal"><span class="pre">OK</span></tt>。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">seconds</span></tt>参数不合法时，返回一个错误。</div>
</div>
</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 情况1：key不存在</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SETEX('cache_user_id', 60,10086);<span style="color: #008000;">//</span><span style="color: #008000;">bool(true)</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GET('cache_user_id');  <span style="color: #008000;">#</span><span style="color: #008000;"> 值 //"10086"</span><span style="color: #008000;"><br /></span><br /><span style="color: #008080;">sleep</span>(4);<br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;TTL('cache_user_id');  <span style="color: #008000;">#</span><span style="color: #008000;"> 剩余生存时间 //int(56)</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：key已经存在，key被覆写</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('cd', "timeless"); <span style="color: #008000;">//</span><span style="color: #008000;">bool(true);</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SETEX('cd', 3000,"goodbye my love"); <span style="color: #008000;">//</span><span style="color: #008000;">bool(true);</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GET('cd');<span style="color: #008000;">//</span><span style="color: #008000;">"goodbye my love"</span></pre>
</div>
<p>&nbsp;</p>
<p><a name="string_SETRANGE"></a><span style="font-size: 18pt;"><strong>SETRANGE</strong></span></p>
<p>SETRANGE key offset value</p>
<p>用<tt class="docutils literal"><span class="pre">value</span></tt>参数覆写(Overwrite)给定<tt class="docutils literal"><span class="pre">key</span></tt>所储存的字符串值，从偏移量<tt class="docutils literal"><span class="pre">offset</span></tt>开始。</p>
<p>不存在的<tt class="docutils literal"><span class="pre">key</span></tt>当作空白字符串处理。</p>
<p><a class="reference internal" href="#string_SETRANGE">SETRANGE</a>命令会确保字符串足够长以便将<tt class="docutils literal"><span class="pre">value</span></tt>设置在指定的偏移量上，如果给定<tt class="docutils literal"><span class="pre">key</span></tt>原来储存的字符串长度比偏移量小(比如字符串只有<tt class="docutils literal"><span class="pre">5</span></tt>个字符长，但你设置的<tt class="docutils literal"><span class="pre">offset</span></tt>是<tt class="docutils literal"><span class="pre">10</span></tt>)，那么原字符和偏移量之间的空白将用零比特(zerobytes,<tt class="docutils literal"><span class="pre">"\x00"</span></tt>)来填充。</p>
<p>注意你能使用的最大偏移量是2^29-1(536870911)，因为Redis的字符串被限制在512兆(megabytes)内。如果你需要使用比这更大的空间，你得使用多个<tt class="docutils literal"><span class="pre">key</span></tt>。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>
<div class="first last line-block">
<div class="line">对小(small)的字符串，平摊复杂度O(1)。(关于什么字符串是&rdquo;小&rdquo;的，请参考<a class="reference internal" href="#string_APPEND">APPEND</a>命令)</div>
<div class="line">否则为O(M)，M为value参数的长度。</div>
</div>
</dd><dt><strong>返回值：</strong></dt><dd>被<a class="reference internal" href="#string_SETRANGE">SETRANGE</a>修改之后，字符串的长度。</dd></dl>
<blockquote>
<p class="first admonition-title">&nbsp;<strong style="color: #ff0000;">警告</strong></p>
<p><span style="color: #ff0000;" data-mce-="">&nbsp;当生成一个很长的字符串时，Redis需要分配内存空间，该操作有时候可能会造成服务器阻塞(block)。在2010年的Macbook Pro上，设置偏移量为536870911(512MB内存分配)，耗费约300毫秒， 设置偏移量为134217728(128MB内存分配)，耗费约80毫秒，设置偏移量33554432(32MB内存分配)，耗费约30毫秒，设置偏移量为8388608(8MB内存分配)，耗费约8毫秒。 注意若首次内存分配成功之后，再对同一个<tt class="docutils literal"><span class="pre">key</span></tt>调用<a class="reference internal" href="#string_SETRANGE"><span style="color: #ff0000;" data-mce-="">SETRANGE</span></a>操作，无须再重新内存。</span></p>
</blockquote>
<p><strong>模式</strong></p>
<p>因为有了<a class="reference internal" href="#string_SETRANGE">SETRANGE</a>和<a class="reference internal" href="#string_GETRANGE">GETRANGE</a>命令，你可以将Redis字符串用作具有O(1)随机访问时间的线性数组。这在很多真实用例中都是非常快速且高效的储存方式。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 情况1：对非空字符串进行SETRANGE</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('greeting', "hello world");<br /><span style="color: #800080;">$redis</span>-&gt;SETRANGE('greeting', 6, "Redis"); <span style="color: #008000;">//</span><span style="color: #008000;">int(11)</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;GET('greeting');<span style="color: #008000;">//</span><span style="color: #008000;">"hello Redis"</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：对空字符串/不存在的key进行SETRANGE</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;EXISTS('empty_string');<span style="color: #008000;">//</span><span style="color: #008000;">bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SETRANGE('empty_string', 5 ,"Redis!");  <span style="color: #008000;">#</span><span style="color: #008000;"> 对不存在的key使用SETRANGE //int(11)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GET('empty_string'));  <span style="color: #008000;">#</span><span style="color: #008000;"> 空白处被"\x00"填充  #"\x00\x00\x00\x00\x00Redis!"   //return string(11) "Redis!"</span></pre>
</div>
<p><strong><a name="string_MSET"></a><span style="font-size: 18pt;">MSET&nbsp;</span></strong><br />MSET key value [key value ...]</p>
<p>同时设置一个或多个<tt class="docutils literal"><span class="pre">key-value</span></tt>对。</p>
<p>当发现同名的<tt class="docutils literal"><span class="pre">key</span></tt>存在时，<a class="reference internal" href="#string_MSET">MSET</a>会用新值覆盖旧值，如果你不希望覆盖同名<tt class="docutils literal"><span class="pre">key</span></tt>，请使用<a class="reference internal" href="#string_MSETNX">MSETNX</a>命令。</p>
<p><a class="reference internal" href="#string_MSET">MSET</a>是一个原子性(atomic)操作，所有给定<tt class="docutils literal"><span class="pre">key</span></tt>都在同一时间内被设置，某些给定<tt class="docutils literal"><span class="pre">key</span></tt>被更新而另一些给定<tt class="docutils literal"><span class="pre">key</span></tt>没有改变的情况，不可能发生。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为要设置的<tt class="docutils literal"><span class="pre">key</span></tt>数量。</dd><dt><strong>返回值：</strong></dt><dd>总是返回<tt class="docutils literal"><span class="pre">OK</span></tt>(因为<tt class="docutils literal"><span class="pre">MSET</span></tt>不可能失败)</dd><dd></dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">MSET</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;MSET&lt;br&gt;';<br /><span style="color: #800080;">$redis</span>-&gt;select(0);<br /><span style="color: #800080;">$redis</span>-&gt;flushdb();<br /><span style="color: #800080;">$array_mset</span>=<span style="color: #0000ff;">array</span>('date'=&gt;'2012.3.5',<br />        'time'=&gt;'9.09a.m.',<br />        'weather'=&gt;'sunny'<br />        );<br /><span style="color: #800080;">$redis</span>-&gt;MSET(<span style="color: #800080;">$array_mset</span>); <span style="color: #008000;">//</span><span style="color: #008000;">bool(true)</span><span style="color: #008000;"><br /></span><br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;KEYS('*'));   <span style="color: #008000;">#</span><span style="color: #008000;"> 确保指定的三个key-value对被插入 //array(3) { [0]=&gt; string(4) "time" [1]=&gt; string(7) "weather" [2]=&gt; string(4) "date" }</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> MSET覆盖旧值的例子 但是经过测试覆盖不了</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;SET('google', "google.cn"));   <span style="color: #008000;">//</span><span style="color: #008000;">bool(true)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;MSET('google',"google.hk")); <span style="color: #008000;">//</span><span style="color: #008000;">bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GET('google'); <span style="color: #008000;">//</span><span style="color: #008000;">google.cn  <strong>与redis手册的示例结果不符</strong></span></pre>
</div>
<p>&nbsp;</p>
<h2><a name="string_MSETNX"></a>MSETNX</h2>
<dl class="function"><dt><tt class="descname">MSETNX key value [key value ...]</tt></dt><dd></dd></dl>
<p>同时设置一个或多个<tt class="docutils literal"><span class="pre">key-value</span></tt>对，当且仅当<tt class="docutils literal"><span class="pre">key</span></tt>不存在。</p>
<p>即使<em>只有一个</em><tt class="docutils literal"><span class="pre">key</span></tt>已存在，<a class="reference internal" href="#string_MSETNX">MSETNX</a>也会拒绝<em>所有</em>传入<tt class="docutils literal"><span class="pre">key</span></tt>的设置操作</p>
<p><a class="reference internal" href="#string_MSETNX">MSETNX</a>是原子性的，因此它可以用作设置多个不同<tt class="docutils literal"><span class="pre">key</span></tt>表示不同字段(field)的唯一性逻辑对象(unique logic object)，所有字段要么全被设置，要么全不被设置。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为要设置的<tt class="docutils literal"><span class="pre">key</span></tt>的数量。</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">当所有<tt class="docutils literal"><span class="pre">key</span></tt>都成功设置，返回<tt class="docutils literal"><span class="pre">1</span></tt>。</div>
<div class="line">如果所有key都设置失败(最少有一个<tt class="docutils literal"><span class="pre">key</span></tt>已经存在)，那么返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 情况1：对不存在的key进行MSETNX</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$array_mset</span>=<span style="color: #0000ff;">array</span>('rmdbs'=&gt;'MySQL',<br />        'nosql'=&gt;'MongoDB',<br />        'key-value-store'=&gt;'redis'<br />        );<br /><span style="color: #800080;">$redis</span>-&gt;MSETNX(<span style="color: #800080;">$array_mset</span>);<span style="color: #008000;">//</span><span style="color: #008000;">bool(true)</span><span style="color: #008000;"><br /></span><br /><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：对已存在的key进行MSETNX</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$array_mset</span>=<span style="color: #0000ff;">array</span>('rmdbs'=&gt;'Sqlite',<br />        'language'=&gt;'python'<br />        );<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;MSETNX(<span style="color: #800080;">$array_mset</span>));  <span style="color: #008000;">#</span><span style="color: #008000;"> rmdbs键已经存在，操作失败 //bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;EXISTS('language'));  <span style="color: #008000;">#</span><span style="color: #008000;"> 因为操作是原子性的，language没有被设置  bool(false)</span><span style="color: #008000;"><br /></span><br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GET('rmdbs');  <span style="color: #008000;">#</span><span style="color: #008000;"> rmdbs没有被修改 //"MySQL"</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$array_mset_keys</span>=<span style="color: #0000ff;">array</span>( 'rmdbs', 'nosql', 'key-value-store');<br /><span style="color: #008080;">print_r</span>(<span style="color: #800080;">$redis</span>-&gt;MGET(<span style="color: #800080;">$array_mset_keys</span>)); <span style="color: #008000;">//</span><span style="color: #008000;">Array ( [0] =&gt; MySQL [1] =&gt; MongoDB [2] =&gt; redis )</span></pre>
</div>
<p>&nbsp;</p>
<h2><a name="string_APPEND"></a>APPEND</h2>
<dl class="function"><dt><tt class="descname">APPEND key value</tt></dt><dd></dd></dl>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>已经存在并且是一个字符串，<a class="reference internal" href="#string_APPEND">APPEND</a>命令将<tt class="docutils literal"><span class="pre">value</span></tt>追加到<tt class="docutils literal"><span class="pre">key</span></tt>原来的值之后。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，<a class="reference internal" href="#string_APPEND">APPEND</a>就简单地将给定<tt class="docutils literal"><span class="pre">key</span></tt>设为<tt class="docutils literal"><span class="pre">value</span></tt>，就像执行<tt class="docutils literal"><span class="pre">SET</span>&nbsp;<span class="pre">key</span>&nbsp;<span class="pre">value</span></tt>一样。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>平摊复杂度O(1)</dd><dt><strong>返回值：</strong></dt><dd>追加<tt class="docutils literal"><span class="pre">value</span></tt>之后，<tt class="docutils literal"><span class="pre">key</span></tt>中字符串的长度。</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 情况1：对不存在的key执行APPEND</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;EXISTS('myphone');  <span style="color: #008000;">#</span><span style="color: #008000;"> 确保myphone不存在 //bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;APPEND('myphone',"nokia");  <span style="color: #008000;">#</span><span style="color: #008000;"> 对不存在的key进行APPEND，等同于SET myphone "nokia" //int(5) # 字符长度</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：对字符串进行APPEND</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;APPEND('myphone', " - 1110");<span style="color: #008000;">#</span><span style="color: #008000;"> 长度从5个字符增加到12个字符 //int(12)</span><span style="color: #008000;"><br /></span><br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GET('myphone');  <span style="color: #008000;">#</span><span style="color: #008000;"> 查看整个字符串 //"nokia - 1110"</span></pre>
</div>
<h2><a name="string_GET"></a>GET</h2>
<dl class="function"><dt><tt class="descname">GET key</tt></dt><dd></dd></dl>
<p>返回<tt class="docutils literal"><span class="pre">key</span></tt>所关联的字符串值。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在则返回特殊值<tt class="docutils literal"><span class="pre">nil</span></tt>。</p>
<p>假如<tt class="docutils literal"><span class="pre">key</span></tt>储存的值不是字符串类型，返回一个错误，因为<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/string.html#get">GET</a>只能用于处理字符串值。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">key</span></tt>的值。</div>
<div class="line">如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，返回<tt class="docutils literal"><span class="pre">nil</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">GET</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GET('fake_key')); <span style="color: #008000;">#</span><span style="color: #008000;">(nil) //return bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('animate', "anohana"); <span style="color: #008000;">//</span><span style="color: #008000;">return bool(true)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GET('animate')); <span style="color: #008000;">//</span><span style="color: #008000;">return string(7) "anohana"</span></pre>
</div>
<p>&nbsp;</p>
<h2><a name="string_MGET"></a>MGET</h2>
<dl class="function"><dt><tt class="descname">MGET key [key ...]</tt></dt><dd></dd></dl>
<p>返回所有(一个或多个)给定<tt class="docutils literal"><span class="pre">key</span></tt>的值。</p>
<p>如果某个指定<tt class="docutils literal"><span class="pre">key</span></tt>不存在，那么返回特殊值<tt class="docutils literal"><span class="pre">nil</span></tt>。因此，该命令永不失败。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>一个包含所有给定<tt class="docutils literal"><span class="pre">key</span></tt>的值的列表。</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">MGET</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;MGET&lt;br&gt;';<br /><span style="color: #800080;">$redis_mget_data_array</span>=<span style="color: #0000ff;">array</span>('name'=&gt;'ikodota','blog'=&gt;'cnblogs.com/ikodota');<br /><span style="color: #800080;">$redis</span>-&gt;MSET(<span style="color: #800080;">$redis_mget_data_array</span>);<span style="color: #008000;">#</span><span style="color: #008000;">用MSET一次储存多个值 </span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis_mget_key_array</span>=<span style="color: #0000ff;">array</span>('name','blog');<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;MGET(<span style="color: #800080;">$redis_mget_key_array</span>)); <span style="color: #008000;">//</span><span style="color: #008000;">array(2) { [0]=&gt; string(7) "ikodota" [1]=&gt; string(19) "cnblogs.com/ikodota" }</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis</span>-&gt;EXISTS('fake_key'); <span style="color: #008000;">//</span><span style="color: #008000;">bool(false)</span><span style="color: #008000;"><br /></span><br /><span style="color: #800080;">$redis_mget_key_array</span>=<span style="color: #0000ff;">array</span>('name','fake_key');<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;MGET(<span style="color: #800080;">$redis_mget_key_array</span>));  <span style="color: #008000;">#</span><span style="color: #008000;"> 当MGET中有不存在key的情况   //array(2) { [0]=&gt; string(7) "ikodota" [1]=&gt; bool(false) }</span></pre>
</div>
<h2><a name="string_GETRANGE"></a>GETRANGE</h2>
<dl class="function"><dt><tt class="descname">GETRANGE key start end</tt></dt><dd></dd></dl>
<p>返回<tt class="docutils literal"><span class="pre">key</span></tt>中字符串值的子字符串，字符串的截取范围由<tt class="docutils literal"><span class="pre">start</span></tt>和<tt class="docutils literal"><span class="pre">end</span></tt>两个偏移量决定(包括<tt class="docutils literal"><span class="pre">start</span></tt>和<tt class="docutils literal"><span class="pre">end</span></tt>在内)。</p>
<p>负数偏移量表示从字符串最后开始计数，<tt class="docutils literal"><span class="pre">-1</span></tt>表示最后一个字符，<tt class="docutils literal"><span class="pre">-2</span></tt>表示倒数第二个，以此类推。</p>
<p><a class="reference internal" href="#string_GETRANGE">GETRANGE</a>通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>
<div class="first last line-block">
<div class="line">O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为要返回的字符串的长度。</div>
<div class="line">复杂度最终由返回值长度决定，但因为从已有字符串中建立子字符串的操作非常廉价(cheap)，所以对于长度不大的字符串，该操作的复杂度也可看作O(1)。</div>
</div>
</dd><dt><strong>返回值：</strong></dt><dd>截取得出的子字符串。</dd></dl>
<blockquote>
<p class="first admonition-title">注解:在&lt;=2.0的版本里，GETRANGE被叫作SUBSTR。</p>
</blockquote>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">GETRANGE</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;GETRANGE&lt;br&gt;';<br /><span style="color: #800080;">$redis</span>-&gt;SET('greeting', "hello, my friend");<br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GETRANGE('greeting', 0, 4).'&lt;br&gt;';  <span style="color: #008000;">#</span><span style="color: #008000;"> 返回索引0-4的字符，包括4。 //"hello"</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GETRANGE('greeting', -1 ,-5).'&lt;br&gt;';  <span style="color: #008000;">#</span><span style="color: #008000;"> 不支持回绕操作  //""</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GETRANGE('greeting', -3 ,-1).'&lt;br&gt;';  <span style="color: #008000;">#</span><span style="color: #008000;"> 负数索引 //"end"</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GETRANGE('greeting', 0, -1).'&lt;br&gt;';  <span style="color: #008000;">#</span><span style="color: #008000;"> 从第一个到最后一个 //"hello, my friend"</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GETRANGE('greeting', 0, 1008611).'&lt;br&gt;';  <span style="color: #008000;">#</span><span style="color: #008000;"> 值域范围不超过实际字符串，超过部分自动被符略 //"hello, my friend"</span></pre>
</div>
<p>&nbsp;</p>
<h2><a name="string_GETSET"></a>GETSET</h2>
<dl class="function"><dt><tt class="descname">GETSET key value</tt></dt><dd></dd></dl>
<p>将给定<tt class="docutils literal"><span class="pre">key</span></tt>的值设为<tt class="docutils literal"><span class="pre">value</span></tt>，并返回<tt class="docutils literal"><span class="pre">key</span></tt>的旧值。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>存在但不是字符串类型时，返回一个错误。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">返回给定<tt class="docutils literal"><span class="pre">key</span></tt>的旧值(old value)。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>没有旧值时，返回<tt class="docutils literal"><span class="pre">nil</span></tt>。</div>
</div>
</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">GETSET</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;GETSET&lt;br&gt;';<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;EXISTS('mail'));<span style="color: #008000;">//</span><span style="color: #008000;">return bool(false);</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GETSET('mail','xxx@google.com'));  <span style="color: #008000;">#</span><span style="color: #008000;"> 因为mail之前不存在，没有旧值，返回nil ,#(nil)   //bool(false)</span><span style="color: #008000;"><br /></span><br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GETSET('mail','xxx@yahoo.com'));  <span style="color: #008000;">#</span><span style="color: #008000;"> mail被更新，旧值被返回 //string(14) "xxx@google.com"</span></pre>
</div>
<p><strong>设计模式</strong></p>
<p><a class="reference internal" href="#string_GETSET">GETSET</a>可以和<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/string.html#incr">INCR</a>组合使用，实现一个有原子性(atomic)复位操作的计数器(counter)。</p>
<p>举例来说，每次当某个事件发生时，进程可能对一个名为<tt class="docutils literal"><span class="pre">mycount</span></tt>的<tt class="docutils literal"><span class="pre">key</span></tt>调用<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/string.html#incr">INCR</a>操作，通常我们还要在一个原子时间内同时完成获得计数器的值和将计数器值复位为<tt class="docutils literal"><span class="pre">0</span></tt>两个操作。</p>
<p>可以用命令<tt class="docutils literal"><span class="pre">GETSET</span>&nbsp;<span class="pre">mycounter</span>&nbsp;<span class="pre">0</span></tt>来实现这一目标。</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">$redis</span>-&gt;SELECT(2);<br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;INCR('mycount').'&lt;br&gt;'; <span style="color: #008000;">#</span><span style="color: #008000;">(integer) 11</span><span style="color: #008000;"><br /></span><br /><span style="color: #0000ff;">if</span>(<span style="color: #800080;">$redis</span>-&gt;GET('mycount')&gt;19){<br />    <span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GETSET('mycount', 0).'&lt;br&gt;';  <span style="color: #008000;">#</span><span style="color: #008000;"> 一个原子内完成GET mycount和SET mycount 0操作 #"11" </span><span style="color: #008000;"><br /></span>}<br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GET('mycount'); <span style="color: #008000;">#</span><span style="color: #008000;">"0"</span></pre>
</div>
<p>&nbsp;</p>
<h2><a name="string_STRLEN"></a>STRLEN</h2>
<dl class="function"><dt><tt class="descname">STRLEN key</tt></dt><dd></dd></dl>
<p>返回<tt class="docutils literal"><span class="pre">key</span></tt>所储存的字符串值的长度。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>储存的不是字符串值时，返回一个错误。</p>
<dl class="docutils"><dt>复杂度：</dt><dd>O(1)</dd><dt>返回值：</dt><dd>
<div class="first last line-block">
<div class="line">字符串值的长度。</div>
<div class="line">当&nbsp;<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #800080;">$redis</span>-&gt;SET('mykey', "Hello world");<br /><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">STRLEN</span>('mykey'); <span style="color: #008000;">//</span><span style="color: #008000;">int(11)</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;<span style="color: #008080;">STRLEN</span>('nonexisting'); <span style="color: #008000;">#</span><span style="color: #008000;"> 不存在的key长度视为0  //int(0)</span></pre>
</div>
<dl class="function"><dt></dt></dl>
<h2><a name="string_INCR"></a>INCR</h2>
<dl class="function"><dt><tt class="descname">INCR key</tt></dt><dd></dd></dl>
<p>将<tt class="docutils literal"><span class="pre">key</span></tt>中储存的数字值增一。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，以<tt class="docutils literal"><span class="pre">0</span></tt>为<tt class="docutils literal"><span class="pre">key</span></tt>的初始值，然后执行<a class="reference internal" href="#string_INCR">INCR</a>操作。</p>
<p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
<p>本操作的值限制在64位(bit)有符号数字表示之内。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>执行<a class="reference internal" href="#string_INCR">INCR</a>命令之后<tt class="docutils literal"><span class="pre">key</span></tt>的值。</dd></dl>
<blockquote>
<p class="first admonition-title"><strong>注解</strong>:这是一个针对字符串的操作，因为Redis没有专用的整数类型，所以key内储存的字符串被解释为十进制64位有符号整数来执行INCR操作。</p>
</blockquote>
<div class="cnblogs_code">
<pre><span style="color: #800080;">$redis</span>-&gt;SET('page_view', 20);<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;INCR('page_view')); <span style="color: #008000;">//</span><span style="color: #008000;">int(21) </span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GET('page_view'));    <span style="color: #008000;">#</span><span style="color: #008000;"> 数字值在Redis中以字符串的形式保存 //string(2) "21</span></pre>
</div>
<h2><a name="string_INCRBY"></a>INCRBY</h2>
<dl class="function"><dt><tt class="descname">INCRBY key increment</tt></dt><dd></dd></dl>
<p>将<tt class="docutils literal"><span class="pre">key</span></tt>所储存的值加上增量<tt class="docutils literal"><span class="pre">increment</span></tt>。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，以<tt class="docutils literal"><span class="pre">0</span></tt>为<tt class="docutils literal"><span class="pre">key</span></tt>的初始值，然后执行<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/string.html#incrby">INCRBY</a>命令。</p>
<p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
<p>本操作的值限制在64位(bit)有符号数字表示之内。</p>
<p>关于更多递增(increment)/递减(decrement)操作信息，参见<a class="reference internal" href="#string_INCR">INCR</a>命令。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>加上<tt class="docutils literal"><span class="pre">increment</span></tt>之后，<tt class="docutils literal"><span class="pre">key</span></tt>的值。</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">INCRBY</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;INCRBY&lt;br&gt;';<br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况1：key存在且是数字值</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('rank', 50);  <span style="color: #008000;">#</span><span style="color: #008000;"> 设置rank为50</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;INCRBY('rank', 20);  <span style="color: #008000;">#</span><span style="color: #008000;"> 给rank加上20</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GET('rank')); <span style="color: #008000;">#</span><span style="color: #008000;">"70"   //string(2) "70"</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：key不存在</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;EXISTS('counter'); <span style="color: #008000;">//</span><span style="color: #008000;">bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;INCRBY('counter'); <span style="color: #008000;">#</span><span style="color: #008000;">int 30  //bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GET('counter')); <span style="color: #008000;">#</span><span style="color: #008000;">30 /<strong>/经测试 与手册上结果不一样</strong>，不能直接从bool型转为int型。 return bool(false) </span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况3：key不是数字值</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('book', "long long ago...");<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;INCRBY('book', 200)); <span style="color: #008000;">#</span><span style="color: #008000;">(error) ERR value is not an integer or out of range   // bool(false)</span></pre>
</div>
<p class="first admonition-title">&nbsp;</p>
<h2><a name="string_DECR"></a>DECR</h2>
<dl class="function"><dt><tt class="descname">DECR key</tt></dt><dd></dd></dl>
<p>将<tt class="docutils literal"><span class="pre">key</span></tt>中储存的数字值减一。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，以<tt class="docutils literal"><span class="pre">0</span></tt>为<tt class="docutils literal"><span class="pre">key</span></tt>的初始值，然后执行<a class="reference internal" href="#string_DECR">DECR</a>操作。</p>
<p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
<p>本操作的值限制在64位(bit)有符号数字表示之内。</p>
<p>关于更多递增(increment)/递减(decrement)操作信息，参见<a class="reference internal" href="#string_INCR">INCR</a>命令。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>执行<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/string.html#decr">DECR</a>命令之后<tt class="docutils literal"><span class="pre">key</span></tt>的值。</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">DECR</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SELECT(3);<br /><span style="color: #800080;">$redis</span>-&gt;flushdb();<br /><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;DECR&lt;br&gt;';<br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况1：对存在的数字值key进行DECR</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('failure_times', 10);<br /><span style="color: #800080;">$redis</span>-&gt;DECR('failure_times'); <span style="color: #008000;">//</span><span style="color: #008000;">int(9)</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GET('failure_times').'&lt;br&gt;';  <span style="color: #008000;">//</span><span style="color: #008000;">string(1) "9"</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：对不存在的key值进行DECR</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;EXISTS('count'); <span style="color: #008000;">#</span><span style="color: #008000;">(integer) 0 //bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;DECR('count');  <span style="color: #008000;">//</span><span style="color: #008000;">int(-1) </span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GET('count').'&lt;br&gt;'; <span style="color: #008000;">//</span><span style="color: #008000;">string(2) "-1"</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况3：对存在但不是数值的key进行DECR</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('company', 'YOUR_CODE_SUCKS.LLC');<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;DECR('company')); <span style="color: #008000;">#</span><span style="color: #008000;">(error) ERR value is not an integer or out of range   //bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$redis</span>-&gt;GET('company').'&lt;br&gt;'; <span style="color: #008000;">//</span><span style="color: #008000;">YOUR_CODE_SUCKS.LLC</span></pre>
</div>
<p>&nbsp;</p>
<h2><a name="string_DECRBY"></a>DECRBY</h2>
<dl class="function"><dt><tt class="descname">DECRBY key decrement</tt></dt><dd></dd></dl>
<p>将<tt class="docutils literal"><span class="pre">key</span></tt>所储存的值减去减量<tt class="docutils literal"><span class="pre">decrement</span></tt>。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，以<tt class="docutils literal"><span class="pre">0</span></tt>为<tt class="docutils literal"><span class="pre">key</span></tt>的初始值，然后执行<a class="reference internal" href="#string_DECRBY">DECRBY</a>操作。</p>
<p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
<p>本操作的值限制在64位(bit)有符号数字表示之内。</p>
<p>关于更多递增(increment)/递减(decrement)操作信息，参见<a class="reference internal" href="#string_INCR">INCR</a>命令。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>减去<tt class="docutils literal"><span class="pre">decrement</span></tt>之后，<tt class="docutils literal"><span class="pre">key</span></tt>的值。</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> 情况1：对存在的数值key进行DECRBY</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;SET('count', 100);<br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;DECRBY('count', 20)); <span style="color: #008000;">//</span><span style="color: #008000;">int(80)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GET('count'));  <span style="color: #008000;">//</span><span style="color: #008000;">string(2) "80"</span><span style="color: #008000;"><br /></span><br /><span style="color: #008000;">#</span><span style="color: #008000;"> 情况2：对不存在的key进行DECRBY</span><span style="color: #008000;"><br /></span><span style="color: #800080;">$redis</span>-&gt;EXISTS('pages');<span style="color: #008000;">#</span><span style="color: #008000;">(integer) 0  //bool(false)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;DECRBY('pages', 10));  <span style="color: #008000;">//</span><span style="color: #008000;">int(-10)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GET('pages')); <span style="color: #008000;">//</span><span style="color: #008000;">string(3) "-10"</span></pre>
</div>
<p>&nbsp;</p>
<h2><a name="string_SETBIT"></a>SETBIT</h2>
<dl class="function"><dt><tt class="descname">SETBIT key offset value</tt></dt><dd></dd></dl>
<p>对<tt class="docutils literal"><span class="pre">key</span></tt>所储存的字符串值，设置或清除指定偏移量上的位(bit)。</p>
<p>位的设置或清除取决于<tt class="docutils literal"><span class="pre">value</span></tt>参数，可以是<tt class="docutils literal"><span class="pre">0</span></tt>也可以是<tt class="docutils literal"><span class="pre">1</span></tt>。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，自动生成一个新的字符串值。</p>
<p>字符串会增长(grown)以确保它可以将<tt class="docutils literal"><span class="pre">value</span></tt>保存在指定的偏移量上。当字符串值增长时，空白位置以<tt class="docutils literal"><span class="pre">0</span></tt>填充。</p>
<p><tt class="docutils literal"><span class="pre">offset</span></tt>参数必须大于或等于<tt class="docutils literal"><span class="pre">0</span></tt>，小于2^32(bit映射被限制在512MB内)。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>指定偏移量原来储存的位（"0"或"1"）.</dd></dl>
<blockquote>
<p class="first admonition-title"><strong>警告:对使用大的<tt class="docutils literal"><span class="pre">offset</span></tt>的<a class="reference internal" href="#string_SETBIT">SETBIT</a>操作来说，内存分配可能造成Redis服务器被阻塞。具体参考<a class="reference internal" href="#string_SETRANGE">SETRANGE</a>命令，warning(警告)部分。</strong></p>
</blockquote>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">SETBIT</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">echo</span> '&lt;br&gt;&lt;br&gt;SETBIT&lt;br&gt;';<br /><span style="color: #800080;">$bit_val</span>=67;<br /><span style="color: #0000ff;">echo</span> <span style="color: #008080;">decbin</span>(<span style="color: #800080;">$bit_val</span>).'&lt;br&gt;'; <span style="color: #008000;">//</span><span style="color: #008000;">1000011</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;SETBIT('bit',1,1));<span style="color: #008000;">//</span><span style="color: #008000;">int(0)  空位上都是0</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;SETBIT('bit',2,0));<span style="color: #008000;">//</span><span style="color: #008000;">int(0)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;SETBIT('bit',3,0));<span style="color: #008000;">//</span><span style="color: #008000;">int(0)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;SETBIT('bit',4,0));<span style="color: #008000;">//</span><span style="color: #008000;">int(0)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;SETBIT('bit',5,0));<span style="color: #008000;">//</span><span style="color: #008000;">int(0)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;SETBIT('bit',6,1));<span style="color: #008000;">//</span><span style="color: #008000;">int(0)</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;SETBIT('bit',7,1));<span style="color: #008000;">//</span><span style="color: #008000;">int(0)</span><span style="color: #008000;"><br /></span><br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GET('bit')); <span style="color: #008000;">//</span><span style="color: #008000;">string(1) "C" ,二进制为：1000011 ,ASCII:67</span><span style="color: #008000;"><br /></span><br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GETBIT('bit', 6 )); <span style="color: #008000;">//</span><span style="color: #008000;">int(1)  取出第6位（从左到右）为&ldquo;1&rdquo;</span><span style="color: #008000;"><br /></span><br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;SETBIT('bit',5,1));<span style="color: #008000;">//</span><span style="color: #008000;">int(0)  把第5位的0改为1</span><span style="color: #008000;"><br /></span><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;SETBIT('bit',6,0));<span style="color: #008000;">//</span><span style="color: #008000;">int(1)  把第6位的1改为0</span><span style="color: #008000;"><br /></span><br /><span style="color: #008080;">var_dump</span>(<span style="color: #800080;">$redis</span>-&gt;GET('bit')); <span style="color: #008000;">//</span><span style="color: #008000;">string(1) "E ,二进制为：1000101,ASCII:69l</span></pre>
</div>
<p><br /><br /></p>
<h2><a name="string_GETBIT"></a>GETBIT</h2>
<dl class="function"><dt><tt class="descname">GETBIT key offset</tt></dt><dd></dd></dl>
<p>对<tt class="docutils literal"><span class="pre">key</span></tt>所储存的字符串值，获取指定偏移量上的位(bit)。</p>
<p>当<tt class="docutils literal"><span class="pre">offset</span></tt>比字符串值的长度大，或者<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>字符串值指定偏移量上的位(bit)。</dd></dl>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;">参见SETBIT的示例</span></pre>
</div>
<p>&nbsp;</p>
<h1><a name="hash"></a>哈希表(Hash)</h1>
<h2><a name="hash_HSET"></a>HSET</h2>
<dl class="function"><dt><tt class="descname">HSET key field value</tt></dt><dd></dd></dl>
<p>将哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中的域<tt class="docutils literal"><span class="pre">field</span></tt>的值设为<tt class="docutils literal"><span class="pre">value</span></tt>。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，一个新的哈希表被创建并进行<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/hash.html#hset">HSET</a>操作。</p>
<p>如果域<tt class="docutils literal"><span class="pre">field</span></tt>已经存在于哈希表中，旧值将被覆盖。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">如果<tt class="docutils literal"><span class="pre">field</span></tt>是哈希表中的一个新建域，并且值设置成功，返回<tt class="docutils literal"><span class="pre">1</span></tt>。</div>
<div class="line">如果哈希表中域<tt class="docutils literal"><span class="pre">field</span></tt>已经存在且旧值已被新值覆盖，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="hash_HSETNX"></a>HSETNX</h2>
<dl class="function"><dt><tt class="descname">HSETNX key field value</tt></dt><dd></dd></dl>
<p>将哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中的域<tt class="docutils literal"><span class="pre">field</span></tt>的值设置为<tt class="docutils literal"><span class="pre">value</span></tt>，当且仅当域<tt class="docutils literal"><span class="pre">field</span></tt>不存在。</p>
<p>若域<tt class="docutils literal"><span class="pre">field</span></tt>已经存在，该操作无效。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，一个新哈希表被创建并执行<a class="reference internal" href="#hash_HSETNX">HSETNX</a>命令。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">设置成功，返回<tt class="docutils literal"><span class="pre">1</span></tt>。</div>
<div class="line">如果给定域已经存在且没有操作被执行，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="hash_HMSET"></a>HMSET</h2>
<dl class="function"><dt><tt class="descname">HMSET key field value [field value ...]</tt></dt><dd></dd></dl>
<p>同时将多个<tt class="docutils literal"><span class="pre">field</span>&nbsp;<span class="pre">-</span>&nbsp;<span class="pre">value</span></tt>(域-值)对设置到哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中。</p>
<p>此命令会覆盖哈希表中已存在的域。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，一个空哈希表被创建并执行<a class="reference internal" href="#hash_HMSET">HMSET</a>操作。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为<tt class="docutils literal"><span class="pre">field</span>&nbsp;<span class="pre">-</span>&nbsp;<span class="pre">value</span></tt>对的数量。</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">如果命令执行成功，返回<tt class="docutils literal"><span class="pre">OK</span></tt>。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>不是哈希表(hash)类型时，返回一个错误。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="hash_HGET"></a>HGET</h2>
<dl class="function"><dt><tt class="descname">HGET key field</tt></dt><dd></dd></dl>
<p>返回哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中给定域<tt class="docutils literal"><span class="pre">field</span></tt>的值。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">给定域的值。</div>
<div class="line">当给定域不存在或是给定<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，返回<tt class="docutils literal"><span class="pre">nil</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="hash_HMGET"></a>HMGET</h2>
<dl class="function"><dt><tt class="descname">HMGET key field [field ...]</tt></dt><dd></dd></dl>
<p>返回哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中，一个或多个给定域的值。</p>
<p>如果给定的域不存在于哈希表，那么返回一个<tt class="docutils literal"><span class="pre">nil</span></tt>值。</p>
<p>因为不存在的<tt class="docutils literal"><span class="pre">key</span></tt>被当作一个空哈希表来处理，所以对一个不存在的<tt class="docutils literal"><span class="pre">key</span></tt>进行<a class="reference internal" href="#hash_HMGET">HMGET</a>操作将返回一个只带有<tt class="docutils literal"><span class="pre">nil</span></tt>值的表。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为给定域的数量。</dd><dt><strong>返回值：</strong></dt><dd>一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="hash_HGETALL"></a>HGETALL</h2>
<dl class="function"><dt><tt class="descname">HGETALL key</tt></dt><dd></dd></dl>
<p>返回哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中，所有的域和值。</p>
<p>在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为哈希表的大小。</dd><dt><strong>返回值：</strong></dt><dd>以列表形式返回哈希表的域和域的值。 若<tt class="docutils literal"><span class="pre">key</span></tt>不存在，返回空列表。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="hash_HDEL"></a>HDEL</h2>
<dl class="function"><dt><tt class="descname">HDEL key field [field ...]</tt></dt><dd></dd></dl>
<p>删除哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中的一个或多个指定域，不存在的域将被忽略。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为要删除的域的数量。</dd><dt><strong>返回值:</strong></dt><dd>被成功移除的域的数量，不包括被忽略的域。</dd></dl>
<blockquote>
<p class="first admonition-title"><strong>注解:</strong>在Redis2.4以下的版本里，<a class="reference internal" href="#hash_HDEL">HDEL</a>每次只能删除单个域，如果你需要在一个原子时间内删除多个域，请将命令包含在<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/transaction.html#multi"><em>MULTI</em></a>/&nbsp;<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/transaction.html#exec"><em>EXEC</em></a>块内。</p>
</blockquote>
<p>&nbsp;</p>
<h2><a name="hash_HLEN"></a>HLEN</h2>
<dl class="function"><dt><tt class="descname">HLEN key</tt></dt><dd></dd></dl>
<p>返回哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中域的数量。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">哈希表中域的数量。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="hash_HEXISTS"></a>HEXISTS</h2>
<dl class="function"><dt><tt class="descname">HEXISTS key field</tt></dt><dd></dd></dl>
<p>查看哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中，给定域<tt class="docutils literal"><span class="pre">field</span></tt>是否存在。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">如果哈希表含有给定域，返回<tt class="docutils literal"><span class="pre">1</span></tt>。</div>
<div class="line">如果哈希表不含有给定域，或<tt class="docutils literal"><span class="pre">key</span></tt>不存在，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="hash_HINCRBY"></a>HINCRBY</h2>
<dl class="function"><dt><tt class="descname">HINCRBY key field increment</tt></dt><dd></dd></dl>
<p>为哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中的域<tt class="docutils literal"><span class="pre">field</span></tt>的值加上增量<tt class="docutils literal"><span class="pre">increment</span></tt>。</p>
<p>增量也可以为负数，相当于对给定域进行减法操作。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，一个新的哈希表被创建并执行<a class="reference internal" href="#hash_HINCRBY">HINCRBY</a>命令。</p>
<p>如果域<tt class="docutils literal"><span class="pre">field</span></tt>不存在，那么在执行命令前，域的值被初始化为<tt class="docutils literal"><span class="pre">0</span></tt>。</p>
<p>对一个储存字符串值的域<tt class="docutils literal"><span class="pre">field</span></tt>执行<a class="reference internal" href="#hash_HINCRBY">HINCRBY</a>命令将造成一个错误。</p>
<p>本操作的值限制在64位(bit)有符号数字表示之内。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>执行<a class="reference internal" href="#hash_HINCRBY">HINCRBY</a>命令之后，哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中域<tt class="docutils literal"><span class="pre">field</span></tt>的值。</dd></dl>
<p>&nbsp;</p>
<h2><a name="hash_HKEYS"></a>HKEYS</h2>
<dl class="function"><dt><tt class="descname">HKEYS key</tt></dt><dd></dd></dl>
<p>返回哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中的所有域。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为哈希表的大小。</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">一个包含哈希表中所有域的表。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，返回一个空表。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="hash_HVALS"></a>HVALS</h2>
<dl class="function"><dt><tt class="descname">HVALS key</tt></dt><dd></dd></dl>
<p>返回哈希表<tt class="docutils literal"><span class="pre">key</span></tt>中的所有值。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为哈希表的大小。</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">一个包含哈希表中所有值的表。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，返回一个空表。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h1><a name="list"></a>表(List)</h1>
<p><strong>头元素和尾元素</strong></p>
<p>头元素指的是列表左端/前端第一个元素，尾元素指的是列表右端/后端第一个元素。</p>
<p>举个例子，列表<tt class="docutils literal"><span class="pre">list</span></tt>包含三个元素：<tt class="docutils literal"><span class="pre">x,</span>&nbsp;<span class="pre">y,</span>&nbsp;<span class="pre">z</span></tt>，其中<tt class="docutils literal"><span class="pre">x</span></tt>是头元素，而<tt class="docutils literal"><span class="pre">z</span></tt>则是尾元素。</p>
<p><strong>空列表</strong></p>
<p>指不包含任何元素的列表，Redis将不存在的<tt class="docutils literal"><span class="pre">key</span></tt>也视为空列表。</p>
<p>&nbsp;</p>
<h2><a name="list_LPUSH"></a>LPUSH</h2>
<dl class="function"><dt><tt class="descname">LPUSH key value [value ...]</tt></dt><dd></dd></dl>
<p>将一个或多个值<tt class="docutils literal"><span class="pre">value</span></tt>插入到列表<tt class="docutils literal"><span class="pre">key</span></tt>的<em>表头</em>。</p>
<p>如果有多个<tt class="docutils literal"><span class="pre">value</span></tt>值，那么各个<tt class="docutils literal"><span class="pre">value</span></tt>值按从左到右的顺序依次插入到表头：比如对一个空列表(<tt class="docutils literal"><span class="pre">mylist</span></tt>)执行<tt class="docutils literal"><span class="pre">LPUSH</span>&nbsp;<span class="pre">mylist</span>&nbsp;<span class="pre">a</span>&nbsp;<span class="pre">b</span>&nbsp;<span class="pre">c</span></tt>，则结果列表为<tt class="docutils literal"><span class="pre">c</span>&nbsp;<span class="pre">b</span>&nbsp;<span class="pre">a</span></tt>，等同于执行执行命令<tt class="docutils literal"><span class="pre">LPUSH</span>&nbsp;<span class="pre">mylist</span>&nbsp;<span class="pre">a</span></tt>、<tt class="docutils literal"><span class="pre">LPUSH</span>&nbsp;<span class="pre">mylist</span>&nbsp;<span class="pre">b</span></tt>、<tt class="docutils literal"><span class="pre">LPUSH</span>&nbsp;<span class="pre">mylist</span>&nbsp;<span class="pre">c</span></tt>。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，一个空列表会被创建并执行<a class="reference internal" href="#list_LPUSH">LPUSH</a>操作。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>存在但不是列表类型时，返回一个错误。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>执行<a class="reference internal" href="#list_LPUSH">LPUSH</a>命令后，列表的长度。</dd></dl>
<p>&nbsp;</p>
<blockquote>
<p class="first admonition-title"><strong>注解:</strong>在Redis 2.4版本以前的<a class="reference internal" href="#list_LPUSH">LPUSH</a>命令，都只接受单个<tt class="docutils literal"><span class="pre">value</span></tt>值。</p>
</blockquote>
<p>&nbsp;</p>
<h2><a name="list_LPUSHX"></a>LPUSHX</h2>
<dl class="function"><dt><tt class="descname">LPUSHX key value</tt></dt><dd></dd></dl>
<p>将值<tt class="docutils literal"><span class="pre">value</span></tt>插入到列表<tt class="docutils literal"><span class="pre">key</span></tt>的表头，当且仅当<tt class="docutils literal"><span class="pre">key</span></tt>存在并且是一个列表。</p>
<p>和<a class="reference internal" href="#list_LPUSH">LPUSH</a>命令相反，当<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，<a class="reference internal" href="#list_LPUSHX">LPUSHX</a>命令什么也不做。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd><a class="reference internal" href="#list_LPUSHX">LPUSHX</a>命令执行之后，表的长度。</dd></dl>
<p>&nbsp;</p>
<h2><a name="list_RPUSH"></a>RPUSH</h2>
<dl class="function"><dt><tt class="descname">RPUSH key value [value ...]</tt></dt><dd></dd></dl>
<p>将一个或多个值<tt class="docutils literal"><span class="pre">value</span></tt>插入到列表<tt class="docutils literal"><span class="pre">key</span></tt>的<em>表尾</em>。</p>
<p>如果有多个<tt class="docutils literal"><span class="pre">value</span></tt>值，那么各个<tt class="docutils literal"><span class="pre">value</span></tt>值按从左到右的顺序依次插入到表尾：比如对一个空列表(<tt class="docutils literal"><span class="pre">mylist</span></tt>)执行<tt class="docutils literal"><span class="pre">RPUSH</span>&nbsp;<span class="pre">mylist</span>&nbsp;<span class="pre">a</span>&nbsp;<span class="pre">b</span>&nbsp;<span class="pre">c</span></tt>，则结果列表为<tt class="docutils literal"><span class="pre">a</span>&nbsp;<span class="pre">b</span>&nbsp;<span class="pre">c</span></tt>，等同于执行命令<tt class="docutils literal"><span class="pre">RPUSH</span><span class="pre">mylist</span>&nbsp;<span class="pre">a</span></tt>、<tt class="docutils literal"><span class="pre">RPUSH</span>&nbsp;<span class="pre">mylist</span>&nbsp;<span class="pre">b</span></tt>、<tt class="docutils literal"><span class="pre">RPUSH</span>&nbsp;<span class="pre">mylist</span>&nbsp;<span class="pre">c</span></tt>。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，一个空列表会被创建并执行<a class="reference internal" href="#list_RPUSH">RPUSH</a>操作。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>存在但不是列表类型时，返回一个错误。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>执行<a class="reference internal" href="#list_RPUSH">RPUSH</a>操作后，表的长度。</dd></dl>
<blockquote>
<p class="first admonition-title"><strong>注解:</strong>在Redis 2.4版本以前的<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/list.html#rpush">RPUSH</a>命令，都只接受单个<tt class="docutils literal"><span class="pre">value</span></tt>值。</p>
</blockquote>
<p>&nbsp;</p>
<h2><a name="list_RPUSHX"></a>RPUSHX</h2>
<dl class="function"><dt><tt class="descname">RPUSHX key value</tt></dt><dd></dd></dl>
<p>将值<tt class="docutils literal"><span class="pre">value</span></tt>插入到列表<tt class="docutils literal"><span class="pre">key</span></tt>的表尾，当且仅当<tt class="docutils literal"><span class="pre">key</span></tt>存在并且是一个列表。</p>
<p>和<a class="reference internal" href="#list_RPUSH">RPUSH</a>命令相反，当<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，<a class="reference internal" href="#list_RPUSHX">RPUSHX</a>命令什么也不做。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd><a class="reference internal" href="#list_RPUSHX">RPUSHX</a>命令执行之后，表的长度。</dd></dl>
<p>&nbsp;</p>
<h2><a name="list_LPOP"></a>LPOP</h2>
<dl class="function"><dt><tt class="descname">LPOP key</tt></dt><dd></dd></dl>
<p>移除并返回列表<tt class="docutils literal"><span class="pre">key</span></tt>的头元素。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">列表的头元素。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，返回<tt class="docutils literal"><span class="pre">nil</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="list_RPOP"></a>RPOP</h2>
<dl class="function"><dt><tt class="descname">RPOP key</tt></dt><dd></dd></dl>
<p>移除并返回列表<tt class="docutils literal"><span class="pre">key</span></tt>的尾元素。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">列表的尾元素。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，返回<tt class="docutils literal"><span class="pre">nil</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="list_BLPOP"></a>BLPOP</h2>
<dl class="function"><dt><tt class="descname">BLPOP key [key ...] timeout</tt></dt><dd></dd></dl>
<p><a class="reference internal" href="#list_BLPOP">BLPOP</a>是列表的阻塞式(blocking)弹出原语。</p>
<p>它是<a class="reference internal" href="#list_LPOP">LPOP</a>命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被<a class="reference internal" href="#list_BLPOP">BLPOP</a>命令阻塞，直到等待超时或发现可弹出元素为止。</p>
<p>当给定多个<tt class="docutils literal"><span class="pre">key</span></tt>参数时，按参数<tt class="docutils literal"><span class="pre">key</span></tt>的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p>
<p><strong>非阻塞行为</strong></p>
<p>当<a class="reference internal" href="#list_BLPOP">BLPOP</a>被调用时，如果给定<tt class="docutils literal"><span class="pre">key</span></tt>内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字一起，组成结果返回给调用者。</p>
<p>当存在多个给定<tt class="docutils literal"><span class="pre">key</span></tt>时，<a class="reference internal" href="#list_BLPOP">BLPOP</a>按给定<tt class="docutils literal"><span class="pre">key</span></tt>参数排列的先后顺序，依次检查各个列表。</p>
<p>假设现在有<tt class="docutils literal"><span class="pre">job</span></tt>、&nbsp;<tt class="docutils literal"><span class="pre">command</span></tt>和<tt class="docutils literal"><span class="pre">request</span></tt>三个列表，其中<tt class="docutils literal"><span class="pre">job</span></tt>不存在，<tt class="docutils literal"><span class="pre">command</span></tt>和<tt class="docutils literal"><span class="pre">request</span></tt>都持有非空列表。考虑以下命令：</p>
<p><tt class="docutils literal"><span class="pre">BLPOP</span>&nbsp;<span class="pre">job</span>&nbsp;<span class="pre">command</span>&nbsp;<span class="pre">request</span>&nbsp;<span class="pre">0</span></tt></p>
<p><a class="reference internal" href="#list_BLPOP">BLPOP</a>保证返回的元素来自<tt class="docutils literal"><span class="pre">command</span></tt>，因为它是按&rdquo;查找<tt class="docutils literal"><span class="pre">job</span></tt>&nbsp;-&gt; 查找<tt class="docutils literal"><span class="pre">command</span></tt>&nbsp;-&gt; 查找<tt class="docutils literal"><span class="pre">request</span></tt>&ldquo;这样的顺序，第一个找到的非空列表。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>阻塞行为</strong></p>
<p>如果所有给定<tt class="docutils literal"><span class="pre">key</span></tt>都不存在或包含空列表，那么<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/list.html#blpop">BLPOP</a>命令将阻塞连接，直到等待超时，或有另一个客户端对给定<tt class="docutils literal"><span class="pre">key</span></tt>的任意一个执行<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/list.html#lpush">LPUSH</a>或<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/list.html#rpush">RPUSH</a>命令为止。</p>
<p>超时参数<tt class="docutils literal"><span class="pre">timeout</span></tt>接受一个以秒为单位的数字作为值。超时参数设为<tt class="docutils literal"><span class="pre">0</span></tt>表示阻塞时间可以无限期延长(block indefinitely) 。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>相同的key被多个客户端同时阻塞</strong></p>
<div class="line-block">
<div class="line">相同的<tt class="docutils literal"><span class="pre">key</span></tt>可以被多个客户端同时阻塞。</div>
<div class="line">不同的客户端被放进一个队列中，按&rdquo;先阻塞先服务&rdquo;(first-BLPOP，first-served)的顺序为<tt class="docutils literal"><span class="pre">key</span></tt>执行<a class="reference internal" href="#list_BLPOP">BLPOP</a>命令。</div>
</div>
<p><strong>在MULTI/EXEC事务中的BLPOP</strong></p>
<p><a class="reference internal" href="#list_BLPOP">BLPOP</a>可以用于流水线(pipline,批量地发送多个命令并读入多个回复)，但把它用在<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/transaction.html#multi"><em>MULTI</em></a>/<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/transaction.html#exec"><em>EXEC</em></a>块当中没有意义。因为这要求整个服务器被阻塞以保证块执行时的原子性，该行为阻止了其他客户端执行<a class="reference internal" href="#list_LPUSH">LPUSH</a>或<a class="reference internal" href="#list_RPUSH">RPUSH</a>命令。</p>
<p>因此，一个被包裹在<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/transaction.html#multi"><em>MULTI</em></a>/<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/transaction.html#exec"><em>EXEC</em></a>块内的<a class="reference internal" href="#list_BLPOP">BLPOP</a>命令，行为表现得就像<a class="reference internal" href="#list_LPOP">LPOP</a>一样，对空列表返回<tt class="docutils literal"><span class="pre">nil</span></tt>，对非空列表弹出列表元素，不进行任何阻塞操作。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>时间复杂度：</strong>O(1)<strong>返回值：</strong></p>
<div class="first last line-block">
<div class="line">如果列表为空，返回一个<tt class="docutils literal"><span class="pre">nil</span></tt>。</div>
<div class="line">反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的<tt class="docutils literal"><span class="pre">key</span></tt>，第二个元素是被弹出元素的值。</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="list_BRPOP"></a>BRPOP</h2>
<dl class="function"><dt><tt class="descname">BRPOP key [key ...] timeout</tt></dt><dd></dd></dl>
<p><a class="reference internal" href="#list_BRPOP">BRPOP</a>是列表的阻塞式(blocking)弹出原语。</p>
<p>它是<a class="reference internal" href="#list_RPOP">RPOP</a>命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被<a class="reference internal" href="#list_BRPOP">BRPOP</a>命令阻塞，直到等待超时或发现可弹出元素为止。</p>
<p>当给定多个<tt class="docutils literal"><span class="pre">key</span></tt>参数时，按参数<tt class="docutils literal"><span class="pre">key</span></tt>的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。</p>
<p>关于阻塞操作的更多信息，请查看<a class="reference internal" href="#list_BLPOP">BLPOP</a>命令，<a class="reference internal" href="#list_BRPOP">BRPOP</a>除了弹出元素的位置和<a class="reference internal" href="#list_BLPOP">BLPOP</a>不同之外，其他表现一致。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">假如在指定时间内没有任何元素被弹出，则返回一个<tt class="docutils literal"><span class="pre">nil</span></tt>和等待时长。</div>
<div class="line">反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的<tt class="docutils literal"><span class="pre">key</span></tt>，第二个元素是被弹出元素的值。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="list_LLEN"></a>LLEN</h2>
<dl class="function"><dt><tt class="descname">LLEN key</tt></dt><dd></dd></dl>
<p>返回列表<tt class="docutils literal"><span class="pre">key</span></tt>的长度。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，则<tt class="docutils literal"><span class="pre">key</span></tt>被解释为一个空列表，返回<tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不是列表类型，返回一个错误。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>列表<tt class="docutils literal"><span class="pre">key</span></tt>的长度。</dd></dl>
<p>&nbsp;</p>
<h2><a name="list_LRANGE"></a>LRANGE</h2>
<dl class="function"><dt><tt class="descname">LRANGE key start stop</tt></dt><dd></dd></dl>
<p>返回列表<tt class="docutils literal"><span class="pre">key</span></tt>中指定区间内的元素，区间以偏移量<tt class="docutils literal"><span class="pre">start</span></tt>和<tt class="docutils literal"><span class="pre">stop</span></tt>指定。</p>
<p>下标(index)参数<tt class="docutils literal"><span class="pre">start</span></tt>和<tt class="docutils literal"><span class="pre">stop</span></tt>都以<tt class="docutils literal"><span class="pre">0</span></tt>为底，也就是说，以<tt class="docutils literal"><span class="pre">0</span></tt>表示列表的第一个元素，以<tt class="docutils literal"><span class="pre">1</span></tt>表示列表的第二个元素，以此类推。</p>
<p>你也可以使用负数下标，以<tt class="docutils literal"><span class="pre">-1</span></tt>表示列表的最后一个元素，<tt class="docutils literal"><span class="pre">-2</span></tt>表示列表的倒数第二个元素，以此类推。</p>
<p><strong>注意LRANGE命令和编程语言区间函数的区别</strong></p>
<p>假如你有一个包含一百个元素的列表，对该列表执行<tt class="docutils literal"><span class="pre">LRANGE</span>&nbsp;<span class="pre">list</span>&nbsp;<span class="pre">0</span>&nbsp;<span class="pre">10</span></tt>，结果是一个包含11个元素的列表，这表明<tt class="docutils literal"><span class="pre">stop</span></tt>下标也在<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/list.html#lrange">LRANGE</a>命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的<tt class="docutils literal"><span class="pre">Range.new</span></tt>、<tt class="docutils literal"><span class="pre">Array#slice</span></tt>和Python的<tt class="docutils literal"><span class="pre">range()</span></tt>函数。</p>
<p><strong>超出范围的下标</strong></p>
<p>超出范围的下标值不会引起错误。</p>
<p>如果<tt class="docutils literal"><span class="pre">start</span></tt>下标比列表的最大下标<tt class="docutils literal"><span class="pre">end</span></tt>(<tt class="docutils literal"><span class="pre">LLEN</span>&nbsp;<span class="pre">list</span></tt>减去<tt class="docutils literal"><span class="pre">1</span></tt>)还要大，或者<tt class="docutils literal"><span class="pre">start</span>&nbsp;<span class="pre">&gt;</span>&nbsp;<span class="pre">stop</span></tt>，<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/list.html#lrange">LRANGE</a>返回一个空列表。</p>
<p>如果<tt class="docutils literal"><span class="pre">stop</span></tt>下标比<tt class="docutils literal"><span class="pre">end</span></tt>下标还要大，Redis将<tt class="docutils literal"><span class="pre">stop</span></tt>的值设置为<tt class="docutils literal"><span class="pre">end</span></tt>。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(S+N)，<tt class="docutils literal"><span class="pre">S</span></tt>为偏移量<tt class="docutils literal"><span class="pre">start</span></tt>，<tt class="docutils literal"><span class="pre">N</span></tt>为指定区间内元素的数量。</dd><dt><strong>返回值:</strong></dt><dd>一个列表，包含指定区间内的元素。</dd></dl>
<p>&nbsp;</p>
<h2><a name="list_LREM"></a>LREM</h2>
<dl class="function"><dt><tt class="descname">LREM key count value</tt></dt><dd></dd></dl>
<p>根据参数<tt class="docutils literal"><span class="pre">count</span></tt>的值，移除列表中与参数<tt class="docutils literal"><span class="pre">value</span></tt>相等的元素。</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">count</span></tt>的值可以是以下几种：</dt><dd>
<ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">count</span>&nbsp;<span class="pre">&gt;</span>&nbsp;<span class="pre">0</span></tt>: 从表头开始向表尾搜索，移除与<tt class="docutils literal"><span class="pre">value</span></tt>相等的元素，数量为<tt class="docutils literal"><span class="pre">count</span></tt>。</li>
<li><tt class="docutils literal"><span class="pre">count</span>&nbsp;<span class="pre">&lt;</span>&nbsp;<span class="pre">0</span></tt>: 从表尾开始向表头搜索，移除与<tt class="docutils literal"><span class="pre">value</span></tt>相等的元素，数量为<tt class="docutils literal"><span class="pre">count</span></tt>的绝对值。</li>
<li><tt class="docutils literal"><span class="pre">count</span>&nbsp;<span class="pre">=</span>&nbsp;<span class="pre">0</span></tt>: 移除表中所有与<tt class="docutils literal"><span class="pre">value</span></tt>相等的值。</li>
</ul>
</dd><dt><strong>时间复杂度：</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为列表的长度。</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">被移除元素的数量。</div>
<div class="line">因为不存在的<tt class="docutils literal"><span class="pre">key</span></tt>被视作空表(empty list)，所以当<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，<a class="reference internal" href="#list_LREM">LREM</a>命令总是返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="list_LSET"></a>LSET</h2>
<dl class="function"><dt><tt class="descname">LSET key index value</tt></dt><dd></dd></dl>
<p>将列表<tt class="docutils literal"><span class="pre">key</span></tt>下标为<tt class="docutils literal"><span class="pre">index</span></tt>的元素的值甚至为<tt class="docutils literal"><span class="pre">value</span></tt>。</p>
<p>更多信息请参考<a class="reference internal" href="#list_LINDEX">LINDEX</a>操作。</p>
<p>当<tt class="docutils literal"><span class="pre">index</span></tt>参数超出范围，或对一个空列表(<tt class="docutils literal"><span class="pre">key</span></tt>不存在)进行<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/list.html#lset">LSET</a>时，返回一个错误。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>
<div class="first last line-block">
<div class="line">对头元素或尾元素进行<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/list.html#lset">LSET</a>操作，复杂度为O(1)。</div>
<div class="line">其他情况下，为O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为列表的长度。</div>
</div>
</dd><dt><strong>返回值：</strong></dt><dd>操作成功返回<tt class="docutils literal"><span class="pre">ok</span></tt>，否则返回错误信息</dd></dl>
<p>&nbsp;</p>
<h2><a name="list_LTRIM"></a>LTRIM</h2>
<dl class="function"><dt><tt class="descname">LTRIM key start stop</tt></dt><dd></dd></dl>
<p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p>
<p>举个例子，执行命令<tt class="docutils literal"><span class="pre">LTRIM</span>&nbsp;<span class="pre">list</span>&nbsp;<span class="pre">0</span>&nbsp;<span class="pre">2</span></tt>，表示只保留列表<tt class="docutils literal"><span class="pre">list</span></tt>的前三个元素，其余元素全部删除。</p>
<p>下标(index)参数<tt class="docutils literal"><span class="pre">start</span></tt>和<tt class="docutils literal"><span class="pre">stop</span></tt>都以<tt class="docutils literal"><span class="pre">0</span></tt>为底，也就是说，以<tt class="docutils literal"><span class="pre">0</span></tt>表示列表的第一个元素，以<tt class="docutils literal"><span class="pre">1</span></tt>表示列表的第二个元素，以此类推。</p>
<p>你也可以使用负数下标，以<tt class="docutils literal"><span class="pre">-1</span></tt>表示列表的最后一个元素，<tt class="docutils literal"><span class="pre">-2</span></tt>表示列表的倒数第二个元素，以此类推。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>不是列表类型时，返回一个错误。</p>
<p><a class="reference internal" href="#list_LTRIM">LTRIM</a>命令通常和<a class="reference internal" href="#list_LPUSH">LPUSH</a>命令或<a class="reference internal" href="#list_RPUSH">RPUSH</a>命令配合使用，举个例子：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>这个例子模拟了一个日志程序，每次将最新日志<tt class="docutils literal"><span class="pre">newest_log</span></tt>放到<tt class="docutils literal"><span class="pre">log</span></tt>列表中，并且只保留最新的<tt class="docutils literal"><span class="pre">100</span></tt>项。注意当这样使用<tt class="docutils literal"><span class="pre">LTRIM</span></tt>命令时，时间复杂度是O(1)，因为平均情况下，每次只有一个元素被移除。</p>
<p><strong>注意LTRIM命令和编程语言区间函数的区别</strong></p>
<p>假如你有一个包含一百个元素的列表<tt class="docutils literal"><span class="pre">list</span></tt>，对该列表执行<tt class="docutils literal"><span class="pre">LTRIM</span>&nbsp;<span class="pre">list</span>&nbsp;<span class="pre">0</span>&nbsp;<span class="pre">10</span></tt>，结果是一个包含11个元素的列表，这表明<tt class="docutils literal"><span class="pre">stop</span></tt>下标也在<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/list.html#ltrim">LTRIM</a>命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的<tt class="docutils literal"><span class="pre">Range.new</span></tt>、<tt class="docutils literal"><span class="pre">Array#slice</span></tt>和Python的<tt class="docutils literal"><span class="pre">range()</span></tt>函数。</p>
<p><strong>超出范围的下标</strong></p>
<p>超出范围的下标值不会引起错误。</p>
<p>如果<tt class="docutils literal"><span class="pre">start</span></tt>下标比列表的最大下标<tt class="docutils literal"><span class="pre">end</span></tt>(<tt class="docutils literal"><span class="pre">LLEN</span>&nbsp;<span class="pre">list</span></tt>减去<tt class="docutils literal"><span class="pre">1</span></tt>)还要大，或者<tt class="docutils literal"><span class="pre">start</span>&nbsp;<span class="pre">&gt;</span>&nbsp;<span class="pre">stop</span></tt>，<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/list.html#ltrim">LTRIM</a>返回一个空列表(因为<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/list.html#ltrim">LTRIM</a>已经将整个列表清空)。</p>
<p>如果<tt class="docutils literal"><span class="pre">stop</span></tt>下标比<tt class="docutils literal"><span class="pre">end</span></tt>下标还要大，Redis将<tt class="docutils literal"><span class="pre">stop</span></tt>的值设置为<tt class="docutils literal"><span class="pre">end</span></tt>。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为被移除的元素的数量。</dd><dt><strong>返回值:</strong></dt><dd>
<div class="first last line-block">
<div class="line">命令执行成功时，返回<tt class="docutils literal"><span class="pre">ok</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="list_LINDEX"></a>LINDEX</h2>
<dl class="function"><dt><tt class="descname">LINDEX key index</tt></dt><dd></dd></dl>
<p>返回列表<tt class="docutils literal"><span class="pre">key</span></tt>中，下标为<tt class="docutils literal"><span class="pre">index</span></tt>的元素。</p>
<p>下标(index)参数<tt class="docutils literal"><span class="pre">start</span></tt>和<tt class="docutils literal"><span class="pre">stop</span></tt>都以<tt class="docutils literal"><span class="pre">0</span></tt>为底，也就是说，以<tt class="docutils literal"><span class="pre">0</span></tt>表示列表的第一个元素，以<tt class="docutils literal"><span class="pre">1</span></tt>表示列表的第二个元素，以此类推。</p>
<p>你也可以使用负数下标，以<tt class="docutils literal"><span class="pre">-1</span></tt>表示列表的最后一个元素，<tt class="docutils literal"><span class="pre">-2</span></tt>表示列表的倒数第二个元素，以此类推。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不是列表类型，返回一个错误。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>
<div class="first last line-block">
<div class="line">O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为到达下标<tt class="docutils literal"><span class="pre">index</span></tt>过程中经过的元素数量。</div>
<div class="line">因此，对列表的头元素和尾元素执行<a class="reference internal" href="#list_LINDEX">LINDEX</a>命令，复杂度为O(1)。</div>
</div>
</dd><dt><strong>返回值:</strong></dt><dd>
<div class="first last line-block">
<div class="line">列表中下标为<tt class="docutils literal"><span class="pre">index</span></tt>的元素。</div>
<div class="line">如果<tt class="docutils literal"><span class="pre">index</span></tt>参数的值不在列表的区间范围内(out of range)，返回<tt class="docutils literal"><span class="pre">nil</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="list_LINSERT"></a>LINSERT</h2>
<dl class="function"><dt><tt class="descname">LINSERT key BEFORE|AFTER pivot value</tt></dt><dd></dd></dl>
<p>将值<tt class="docutils literal"><span class="pre">value</span></tt>插入到列表<tt class="docutils literal"><span class="pre">key</span></tt>当中，位于值<tt class="docutils literal"><span class="pre">pivot</span></tt>之前或之后。</p>
<p>当<tt class="docutils literal"><span class="pre">pivot</span></tt>不存在于列表<tt class="docutils literal"><span class="pre">key</span></tt>时，不执行任何操作。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，<tt class="docutils literal"><span class="pre">key</span></tt>被视为空列表，不执行任何操作。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不是列表类型，返回一个错误。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为寻找<tt class="docutils literal"><span class="pre">pivot</span></tt>过程中经过的元素数量。</dd><dt><strong>返回值:</strong></dt><dd>
<div class="first last line-block">
<div class="line">如果命令执行成功，返回插入操作完成之后，列表的长度。</div>
<div class="line">如果没有找到<tt class="docutils literal"><span class="pre">pivot</span></tt>，返回<tt class="docutils literal"><span class="pre">-1</span></tt>。</div>
<div class="line">如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在或为空列表，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="list_RPOPLPUSH"></a>RPOPLPUSH</h2>
<dl class="function"><dt><tt class="descname">RPOPLPUSH source destination</tt></dt><dd></dd></dl>
<p>命令<a class="reference internal" href="#list_RPOPLPUSH">RPOPLPUSH</a>在一个原子时间内，执行以下两个动作：</p>
<blockquote>
<div>
<ul class="simple">
<li>将列表<tt class="docutils literal"><span class="pre">source</span></tt>中的最后一个元素(尾元素)弹出，并返回给客户端。</li>
<li>将<tt class="docutils literal"><span class="pre">source</span></tt>弹出的元素插入到列表<tt class="docutils literal"><span class="pre">destination</span></tt>，作为<tt class="docutils literal"><span class="pre">destination</span></tt>列表的的头元素。</li>
</ul>
</div>
</blockquote>
<p>举个例子，你有两个列表<tt class="docutils literal"><span class="pre">source</span></tt>和<tt class="docutils literal"><span class="pre">destination</span></tt>，<tt class="docutils literal"><span class="pre">source</span></tt>列表有元素<tt class="docutils literal"><span class="pre">a,</span>&nbsp;<span class="pre">b,</span>&nbsp;<span class="pre">c</span></tt>，<tt class="docutils literal"><span class="pre">destination</span></tt>列表有元素<tt class="docutils literal"><span class="pre">x,</span>&nbsp;<span class="pre">y,</span>&nbsp;<span class="pre">z</span></tt>，执行<tt class="docutils literal"><span class="pre">RPOPLPUSH</span>&nbsp;<span class="pre">source</span>&nbsp;<span class="pre">destination</span></tt>之后，<tt class="docutils literal"><span class="pre">source</span></tt>列表包含元素<tt class="docutils literal"><span class="pre">a,</span>&nbsp;<span class="pre">b</span></tt>，<tt class="docutils literal"><span class="pre">destination</span></tt>列表包含元素<tt class="docutils literal"><span class="pre">c,</span>&nbsp;<span class="pre">x,</span>&nbsp;<span class="pre">y,</span>&nbsp;<span class="pre">z</span></tt>&nbsp;，并且元素<tt class="docutils literal"><span class="pre">c</span></tt>被返回。</p>
<p>如果<tt class="docutils literal"><span class="pre">source</span></tt>不存在，值<tt class="docutils literal"><span class="pre">nil</span></tt>被返回，并且不执行其他动作。</p>
<p>如果<tt class="docutils literal"><span class="pre">source</span></tt>和<tt class="docutils literal"><span class="pre">destination</span></tt>相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>被弹出的元素。</dd></dl>
<p>&nbsp;</p>
<p><strong>设计模式： 一个安全的队列</strong></p>
<p>Redis的列表经常被用作队列(queue)，用于在不同程序之间有序地交换消息(message)。一个程序(称之为生产者，producer)通过<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/list.html#lpush">LPUSH</a>命令将消息放入队列中，而另一个程序(称之为消费者，consumer)通过<a class="reference internal" href="#list_RPOP">RPOP</a>命令取出队列中等待时间最长的消息。</p>
<p>不幸的是，在这个过程中，一个消费者可能在获得一个消息之后崩溃，而未执行完成的消息也因此丢失。</p>
<p>使用<a class="reference internal" href="#list_RPOPLPUSH">RPOPLPUSH</a>命令可以解决这个问题，因为它在返回一个消息之余，还将该消息添加到另一个列表当中，另外的这个列表可以用作消息的备份表：假如一切正常，当消费者完成该消息的处理之后，可以用<a class="reference internal" href="#list_LREM">LREM</a>命令将该消息从备份表删除。</p>
<p>另一方面，助手(helper)程序可以通过监视备份表，将超过一定处理时限的消息重新放入队列中去(负责处理该消息的消费者可能已经崩溃)，这样就不会丢失任何消息了。</p>
<p>&nbsp;</p>
<h2><a name="list_BRPOPLPUSH"></a>BRPOPLPUSH</h2>
<dl class="function"><dt><tt class="descname">BRPOPLPUSH source destination timeout</tt></dt><dd></dd></dl>
<p><a class="reference internal" href="#list_BRPOPLPUSH">BRPOPLPUSH</a>是<a class="reference internal" href="#list_RPOPLPUSH">RPOPLPUSH</a>的阻塞版本，当给定列表<tt class="docutils literal"><span class="pre">source</span></tt>不为空时，<a class="reference internal" href="#list_BRPOPLPUSH">BRPOPLPUSH</a>的表现和<a class="reference internal" href="#list_RPOPLPUSH">RPOPLPUSH</a>一样。</p>
<p>当列表<tt class="docutils literal"><span class="pre">source</span></tt>为空时，<a class="reference internal" href="#list_BRPOPLPUSH">BRPOPLPUSH</a>命令将阻塞连接，直到等待超时，或有另一个客户端对<tt class="docutils literal"><span class="pre">source</span></tt>执行<a class="reference internal" href="#list_LPUSH">LPUSH</a>或<a class="reference internal" href="#list_RPUSH">RPUSH</a>命令为止。</p>
<p>超时参数<tt class="docutils literal"><span class="pre">timeout</span></tt>接受一个以秒为单位的数字作为值。超时参数设为<tt class="docutils literal"><span class="pre">0</span></tt>表示阻塞时间可以无限期延长(block indefinitely) 。</p>
<p>更多相关信息，请参考<a class="reference internal" href="#list_RPOPLPUSH">RPOPLPUSH</a>命令。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">假如在指定时间内没有任何元素被弹出，则返回一个<tt class="docutils literal"><span class="pre">nil</span></tt>和等待时长。</div>
<div class="line">反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1><a name="set"></a>集合(Set)</h1>
<p>&nbsp;附录，常用集合运算：</p>
<blockquote>
<p>&nbsp; &nbsp;A = {'a', 'b', 'c'}<br />B = {'a', 'e', 'i', 'o', 'u'}</p>
<pre>inter(x, y): 交集，在集合x和集合y中都存在的元素。
inter(A, B) = {'a'}

union(x, y): 并集，在集合x中或集合y中的元素，如果一个元素在x和y中都出现，那只记录一次即可。
union(A,B) = {'a', 'b', 'c', 'e', 'i', 'o', 'u'}

diff(x, y): 差集，在集合x中而不在集合y中的元素。
diff(A,B) = {'b', 'c'}

card(x): 基数，一个集合中元素的数量。
card(A) = 3

空集： 基数为0的集合。</pre>
</blockquote>
<p>&nbsp;</p>
<h2><a name="set_SADD"></a>SADD</h2>
<dl class="function"><dt><tt class="descname">SADD key member [member ...]</tt></dt><dd></dd></dl>
<p>将一个或多个<tt class="docutils literal"><span class="pre">member</span></tt>元素加入到集合<tt class="docutils literal"><span class="pre">key</span></tt>当中，已经存在于集合的<tt class="docutils literal"><span class="pre">member</span></tt>元素将被忽略。</p>
<p>假如<tt class="docutils literal"><span class="pre">key</span></tt>不存在，则创建一个只包含<tt class="docutils literal"><span class="pre">member</span></tt>元素作成员的集合。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>不是集合类型时，返回一个错误。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>是被添加的元素的数量。</dd><dt><strong>返回值:</strong></dt><dd>被添加到集合中的<em>新</em>元素的数量，不包括被忽略的元素。</dd></dl>
<blockquote>
<p class="first admonition-title"><strong>注解:</strong>在Redis2.4版本以前，<a class="reference internal" href="#set_SADD">SADD</a>只接受单个<tt class="docutils literal"><span class="pre">member</span></tt>值。</p>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="set_SREM"></a>SREM</h2>
<dl class="function"><dt><tt class="descname">SREM key member [member ...]</tt></dt><dd></dd></dl>
<p>移除集合<tt class="docutils literal"><span class="pre">key</span></tt>中的一个或多个<tt class="docutils literal"><span class="pre">member</span></tt>元素，不存在的<tt class="docutils literal"><span class="pre">member</span></tt>元素会被忽略。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>不是集合类型，返回一个错误。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为给定<tt class="docutils literal"><span class="pre">member</span></tt>元素的数量。</dd><dt><strong>返回值:</strong></dt><dd>被成功移除的元素的数量，不包括被忽略的元素。</dd></dl>
<blockquote>
<p class="first admonition-title"><strong>注解:</strong>在Redis2.4版本以前，<a class="reference internal" href="#set_SREM">SREM</a>只接受单个<tt class="docutils literal"><span class="pre">member</span></tt>值。</p>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="set_SMEMBERS"></a>SMEMBERS</h2>
<dl class="function"><dt><tt class="descname">SMEMBERS key</tt></dt><dd></dd></dl>
<p>返回集合<tt class="docutils literal"><span class="pre">key</span></tt>中的所有成员。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>为集合的基数。</dd><dt><strong>返回值:</strong></dt><dd>集合中的所有成员。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="set_SISMEMBER"></a>SISMEMBER</h2>
<dl class="function"><dt><tt class="descname">SISMEMBER key member</tt></dt><dd></dd></dl>
<p>判断<tt class="docutils literal"><span class="pre">member</span></tt>元素是否是集合<tt class="docutils literal"><span class="pre">key</span></tt>的成员。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(1)</dd><dt><strong>返回值:</strong></dt><dd>
<div class="first last line-block">
<div class="line">如果<tt class="docutils literal"><span class="pre">member</span></tt>元素是集合的成员，返回<tt class="docutils literal"><span class="pre">1</span></tt>。</div>
<div class="line">如果<tt class="docutils literal"><span class="pre">member</span></tt>元素不是集合的成员，或<tt class="docutils literal"><span class="pre">key</span></tt>不存在，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="set_SCARD"></a>SCARD</h2>
<dl class="function"><dt><tt class="descname">SCARD key</tt></dt><dd></dd></dl>
<p>返回集合<tt class="docutils literal"><span class="pre">key</span></tt>的<strong>基数</strong>(集合中元素的数量)。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">集合的基数。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="set_SMOVE"></a>SMOVE</h2>
<dl class="function"><dt><tt class="descname">SMOVE source destination member</tt></dt><dd></dd></dl>
<p>将<tt class="docutils literal"><span class="pre">member</span></tt>元素从<tt class="docutils literal"><span class="pre">source</span></tt>集合移动到<tt class="docutils literal"><span class="pre">destination</span></tt>集合。</p>
<p><a class="reference internal" href="#set_SMOVE">SMOVE</a>是原子性操作。</p>
<p>如果<tt class="docutils literal"><span class="pre">source</span></tt>集合不存在或不包含指定的<tt class="docutils literal"><span class="pre">member</span></tt>元素，则<a class="reference internal" href="#set_SMOVE">SMOVE</a>命令不执行任何操作，仅返回<tt class="docutils literal"><span class="pre">0</span></tt>。否则，<tt class="docutils literal"><span class="pre">member</span></tt>元素从<tt class="docutils literal"><span class="pre">source</span></tt>集合中被移除，并添加到<tt class="docutils literal"><span class="pre">destination</span></tt>集合中去。</p>
<p>当<tt class="docutils literal"><span class="pre">destination</span></tt>集合已经包含<tt class="docutils literal"><span class="pre">member</span></tt>元素时，<a class="reference internal" href="#set_SMOVE">SMOVE</a>命令只是简单地将<tt class="docutils literal"><span class="pre">source</span></tt>集合中的<tt class="docutils literal"><span class="pre">member</span></tt>元素删除。</p>
<p>当<tt class="docutils literal"><span class="pre">source</span></tt>或<tt class="docutils literal"><span class="pre">destination</span></tt>不是集合类型时，返回一个错误。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(1)</dd><dt><strong>返回值:</strong></dt><dd>
<div class="first last line-block">
<div class="line">如果<tt class="docutils literal"><span class="pre">member</span></tt>元素被成功移除，返回<tt class="docutils literal"><span class="pre">1</span></tt>。</div>
<div class="line">如果<tt class="docutils literal"><span class="pre">member</span></tt>元素不是<tt class="docutils literal"><span class="pre">source</span></tt>集合的成员，并且没有任何操作对<tt class="docutils literal"><span class="pre">destination</span></tt>集合执行，那么返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="set_SPOP"></a>SPOP</h2>
<dl class="function"><dt><tt class="descname">SPOP key</tt></dt><dd></dd></dl>
<p>移除并返回集合中的一个随机元素。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(1)</dd><dt><strong>返回值:</strong></dt><dd>
<div class="first last line-block">
<div class="line">被移除的随机元素。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>不存在或<tt class="docutils literal"><span class="pre">key</span></tt>是空集时，返回<tt class="docutils literal"><span class="pre">nil</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<blockquote>
<p class="first admonition-title"><strong>也可以参考:</strong>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用<a class="reference internal" href="#set_SRANDMEMBER">SRANDMEMBER</a>命令。</p>
</blockquote>
<p>&nbsp;</p>
<h2><a name="set_SRANDMEMBER"></a>SRANDMEMBER</h2>
<dl class="function"><dt><tt class="descname">SRANDMEMBER key</tt></dt><dd></dd></dl>
<p>返回集合中的一个随机元素。</p>
<p>该操作和<a class="reference internal" href="#set_SPOP">SPOP</a>相似，但<a class="reference internal" href="#set_SPOP">SPOP</a>将随机元素从集合中移除并返回，而<a class="reference internal" href="#set_SRANDMEMBER">SRANDMEMBER</a>则仅仅返回随机元素，而不对集合进行任何改动。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(1)</dd><dt><strong>返回值:</strong></dt><dd>被选中的随机元素。 当<tt class="docutils literal"><span class="pre">key</span></tt>不存在或<tt class="docutils literal"><span class="pre">key</span></tt>是空集时，返回<tt class="docutils literal"><span class="pre">nil</span></tt>。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="set_SINTER"></a>SINTER</h2>
<dl class="function"><dt><tt class="descname">SINTER key [key ...]</tt></dt><dd></dd></dl>
<p>返回一个集合的全部成员，该集合是所有给定集合的<em>交集</em>。</p>
<p>不存在的<tt class="docutils literal"><span class="pre">key</span></tt>被视为空集。</p>
<p>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N * M)，<tt class="docutils literal"><span class="pre">N</span></tt>为给定集合当中基数最小的集合，<tt class="docutils literal"><span class="pre">M</span></tt>为给定集合的个数。</dd><dt><strong>返回值:</strong></dt><dd>交集成员的列表。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="set_SINTERSTORE"></a>SINTERSTORE</h2>
<dl class="function"><dt><tt class="descname">SINTERSTORE destination key [key ...]</tt></dt><dd></dd></dl>
<p>此命令等同于<a class="reference internal" href="#set_SINTER">SINTER</a>，但它将结果保存到<tt class="docutils literal"><span class="pre">destination</span></tt>集合，而不是简单地返回结果集。</p>
<p>如果<tt class="docutils literal"><span class="pre">destination</span></tt>集合已经存在，则将其覆盖。</p>
<p><tt class="docutils literal"><span class="pre">destination</span></tt>可以是<tt class="docutils literal"><span class="pre">key</span></tt>本身。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N * M)，<tt class="docutils literal"><span class="pre">N</span></tt>为给定集合当中基数最小的集合，<tt class="docutils literal"><span class="pre">M</span></tt>为给定集合的个数。</dd><dt><strong>返回值:</strong></dt><dd>结果集中的成员数量。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="set_SUNION"></a>SUNION</h2>
<dl class="function"><dt><tt class="descname">SUNION key [key ...]</tt></dt><dd></dd></dl>
<p>返回一个集合的全部成员，该集合是所有给定集合的<em>并集</em>。</p>
<p>不存在的<tt class="docutils literal"><span class="pre">key</span></tt>被视为空集。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>是所有给定集合的成员数量之和。</dd><dt><strong>返回值:</strong></dt><dd>并集成员的列表。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="set_SUNIONSTORE"></a>SUNIONSTORE</h2>
<dl class="function"><dt><tt class="descname">SUNIONSTORE destination key [key ...]</tt></dt><dd></dd></dl>
<p>此命令等同于<a class="reference internal" href="#set_SUNION">SUNION</a>，但它将结果保存到<tt class="docutils literal"><span class="pre">destination</span></tt>集合，而不是简单地返回结果集。</p>
<p>如果<tt class="docutils literal"><span class="pre">destination</span></tt>已经存在，则将其覆盖。</p>
<p><tt class="docutils literal"><span class="pre">destination</span></tt>可以是<tt class="docutils literal"><span class="pre">key</span></tt>本身。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>是所有给定集合的成员数量之和。</dd><dt><strong>返回值:</strong></dt><dd>结果集中的元素数量。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="set_SDIFF"></a>SDIFF</h2>
<dl class="function"><dt><tt class="descname">SDIFF key [key ...]</tt></dt><dd></dd></dl>
<p>返回一个集合的全部成员，该集合是所有给定集合的<em>差集</em>&nbsp;。</p>
<p>不存在的<tt class="docutils literal"><span class="pre">key</span></tt>被视为空集。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>是所有给定集合的成员数量之和。</dd><dt><strong>返回值:</strong></dt><dd>交集成员的列表。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="set_SDIFFSTORE"></a>SDIFFSTORE</h2>
<dl class="function"><dt><tt class="descname">SDIFFSTORE destination key [key ...]</tt></dt><dd></dd></dl>
<p>此命令等同于<a class="reference internal" href="#set_SDIFF">SDIFF</a>，但它将结果保存到<tt class="docutils literal"><span class="pre">destination</span></tt>集合，而不是简单地返回结果集。</p>
<p>如果<tt class="docutils literal"><span class="pre">destination</span></tt>集合已经存在，则将其覆盖。</p>
<p><tt class="docutils literal"><span class="pre">destination</span></tt>可以是<tt class="docutils literal"><span class="pre">key</span></tt>本身。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N)，<tt class="docutils literal"><span class="pre">N</span></tt>是所有给定集合的成员数量之和。</dd><dt><strong>返回值:</strong></dt><dd>结果集中的元素数量。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1><a name="Sorted-Set"></a>有序集(Sorted Set)</h1>
<h2><a name="z_ZADD"></a>ZADD</h2>
<p>&nbsp;</p>
<dl class="function"><dt><tt class="descname">ZADD key score member [[score member] [score member] ...]</tt></dt><dd></dd></dl>
<p>将一个或多个<tt class="docutils literal"><span class="pre">member</span></tt>元素及其<tt class="docutils literal"><span class="pre">score</span></tt>值加入到有序集<tt class="docutils literal"><span class="pre">key</span></tt>当中。</p>
<p>如果某个<tt class="docutils literal"><span class="pre">member</span></tt>已经是有序集的成员，那么更新这个<tt class="docutils literal"><span class="pre">member</span></tt>的<tt class="docutils literal"><span class="pre">score</span></tt>值，并通过重新插入这个<tt class="docutils literal"><span class="pre">member</span></tt>元素，来保证该<tt class="docutils literal"><span class="pre">member</span></tt>在正确的位置上。</p>
<p><tt class="docutils literal"><span class="pre">score</span></tt>值可以是整数值或双精度浮点数。</p>
<p>如果<tt class="docutils literal"><span class="pre">key</span></tt>不存在，则创建一个空的有序集并执行<a class="reference internal" href="#z_ZADD">ZADD</a>操作。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>存在但不是有序集类型时，返回一个错误。</p>
<p>对有序集的更多介绍请参见<a class="reference external" href="#Sorted-Set">sorted set</a>。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(M*log(N))，<tt class="docutils literal"><span class="pre">N</span></tt>是有序集的基数，<tt class="docutils literal"><span class="pre">M</span></tt>为成功添加的新成员的数量。</dd><dt><strong>返回值:</strong></dt><dd>被成功添加的<em>新</em>成员的数量，不包括那些被更新的、已经存在的成员。</dd></dl>
<p>&nbsp;</p>
<blockquote>
<p>&nbsp;</p>
<p class="first admonition-title"><strong>注解:</strong>在Redis2.4版本以前，<a class="reference internal" href="#z_ZADD">ZADD</a>每次只能添加一个元素。</p>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="z_ZREM"></a>ZREM</h2>
<dl class="function"><dt><tt class="descname">ZREM key member [member ...]</tt></dt><dd></dd></dl>
<p>移除有序集<tt class="docutils literal"><span class="pre">key</span></tt>中的一个或多个成员，不存在的成员将被忽略。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>存在但不是有序集类型时，返回一个错误。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(M*log(N))，<tt class="docutils literal"><span class="pre">N</span></tt>为有序集的基数，<tt class="docutils literal"><span class="pre">M</span></tt>为被成功移除的成员的数量。</dd><dt><strong>返回值:</strong></dt><dd>被成功移除的成员的数量，不包括被忽略的成员。</dd></dl>
<blockquote>
<p class="first admonition-title"><strong>注解：</strong>在Redis2.4版本以前，<a class="reference internal" href="#z_ZREM">ZREM</a>每次只能删除一个元素。</p>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="z_ZCARD"></a>ZCARD</h2>
<dl class="function"><dt><tt class="descname">ZCARD key</tt></dt><dd></dd></dl>
<p>返回有序集<tt class="docutils literal"><span class="pre">key</span></tt>的基数。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(1)</dd><dt><strong>返回值:</strong></dt><dd>
<div class="first last line-block">
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>存在且是有序集类型时，返回有序集的基数。</div>
<div class="line">当<tt class="docutils literal"><span class="pre">key</span></tt>不存在时，返回<tt class="docutils literal"><span class="pre">0</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="z_ZCOUNT"></a>ZCOUNT</h2>
<dl class="function"><dt><tt class="descname">ZCOUNT key min max</tt></dt><dd></dd></dl>
<p>返回有序集<tt class="docutils literal"><span class="pre">key</span></tt>中，<tt class="docutils literal"><span class="pre">score</span></tt>值在<tt class="docutils literal"><span class="pre">min</span></tt>和<tt class="docutils literal"><span class="pre">max</span></tt>之间(默认包括<tt class="docutils literal"><span class="pre">score</span></tt>值等于<tt class="docutils literal"><span class="pre">min</span></tt>或<tt class="docutils literal"><span class="pre">max</span></tt>)的成员。</p>
<p>关于参数<tt class="docutils literal"><span class="pre">min</span></tt>和<tt class="docutils literal"><span class="pre">max</span></tt>的详细使用方法，请参考<a class="reference internal" href="#z_ZRANGEBYSCORE">ZRANGEBYSCORE</a>命令。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(log(N)+M)，<tt class="docutils literal"><span class="pre">N</span></tt>为有序集的基数，<tt class="docutils literal"><span class="pre">M</span></tt>为值在<tt class="docutils literal"><span class="pre">min</span></tt>和<tt class="docutils literal"><span class="pre">max</span></tt>之间的元素的数量。</dd><dt><strong>返回值:</strong></dt><dd><tt class="docutils literal"><span class="pre">score</span></tt>值在<tt class="docutils literal"><span class="pre">min</span></tt>和<tt class="docutils literal"><span class="pre">max</span></tt>之间的成员的数量。</dd></dl>
<p>&nbsp;</p>
<h2><a name="z_ZSCORE"></a>ZSCORE</h2>
<dl class="function"><dt><tt class="descname">ZSCORE key member</tt></dt><dd></dd></dl>
<p>返回有序集<tt class="docutils literal"><span class="pre">key</span></tt>中，成员<tt class="docutils literal"><span class="pre">member</span></tt>的<tt class="docutils literal"><span class="pre">score</span></tt>值。</p>
<p>如果<tt class="docutils literal"><span class="pre">member</span></tt>元素不是有序集<tt class="docutils literal"><span class="pre">key</span></tt>的成员，或<tt class="docutils literal"><span class="pre">key</span></tt>不存在，返回<tt class="docutils literal"><span class="pre">nil</span></tt>。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(1)</dd><dt><strong>返回值:</strong></dt><dd><tt class="docutils literal"><span class="pre">member</span></tt>成员的<tt class="docutils literal"><span class="pre">score</span></tt>值，以字符串形式表示。</dd></dl>
<p>&nbsp;</p>
<h2><a name="z_ZINCRBY"></a>ZINCRBY</h2>
<dl class="function"><dt><tt class="descname">ZINCRBY key increment member</tt></dt><dd></dd></dl>
<p>为有序集<tt class="docutils literal"><span class="pre">key</span></tt>的成员<tt class="docutils literal"><span class="pre">member</span></tt>的<tt class="docutils literal"><span class="pre">score</span></tt>值加上增量<tt class="docutils literal"><span class="pre">increment</span></tt>。</p>
<p>你也可以通过传递一个负数值<tt class="docutils literal"><span class="pre">increment</span></tt>，让<tt class="docutils literal"><span class="pre">score</span></tt>减去相应的值，比如<tt class="docutils literal"><span class="pre">ZINCRBY</span>&nbsp;<span class="pre">key</span>&nbsp;<span class="pre">-5</span>&nbsp;<span class="pre">member</span></tt>，就是让<tt class="docutils literal"><span class="pre">member</span></tt>的<tt class="docutils literal"><span class="pre">score</span></tt>值减去<tt class="docutils literal"><span class="pre">5</span></tt>。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>不存在，或<tt class="docutils literal"><span class="pre">member</span></tt>不是<tt class="docutils literal"><span class="pre">key</span></tt>的成员时，<tt class="docutils literal"><span class="pre">ZINCRBY</span>&nbsp;<span class="pre">key</span>&nbsp;<span class="pre">increment</span>&nbsp;<span class="pre">member</span></tt>等同于<tt class="docutils literal"><span class="pre">ZADD</span>&nbsp;<span class="pre">key</span>&nbsp;<span class="pre">increment</span>&nbsp;<span class="pre">member</span></tt>。</p>
<p>当<tt class="docutils literal"><span class="pre">key</span></tt>不是有序集类型时，返回一个错误。</p>
<p><tt class="docutils literal"><span class="pre">score</span></tt>值可以是整数值或双精度浮点数。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(log(N))</dd><dt><strong>返回值:</strong></dt><dd><tt class="docutils literal"><span class="pre">member</span></tt>成员的新<tt class="docutils literal"><span class="pre">score</span></tt>值，以字符串形式表示。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="z_ZRANGE"></a>ZRANGE</h2>
<dl class="function"><dt><tt class="descname">ZRANGE key start stop [WITHSCORES]</tt></dt><dd></dd></dl>
<p>返回有序集<tt class="docutils literal"><span class="pre">key</span></tt>中，指定区间内的成员。</p>
<p>其中成员的位置按<tt class="docutils literal"><span class="pre">score</span></tt>值递增(从小到大)来排序。</p>
<p>具有相同<tt class="docutils literal"><span class="pre">score</span></tt>值的成员按字典序(<a class="reference external" href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographical order</a>)来排列。</p>
<p>如果你需要成员按<tt class="docutils literal"><span class="pre">score</span></tt>值递减(从大到小)来排列，请使用<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/sorted_set.html#zrevrange">ZREVRANGE</a>命令。</p>
<div class="line-block">
<div class="line">下标参数<tt class="docutils literal"><span class="pre">start</span></tt>和<tt class="docutils literal"><span class="pre">stop</span></tt>都以<tt class="docutils literal"><span class="pre">0</span></tt>为底，也就是说，以<tt class="docutils literal"><span class="pre">0</span></tt>表示有序集第一个成员，以<tt class="docutils literal"><span class="pre">1</span></tt>表示有序集第二个成员，以此类推。</div>
<div class="line">你也可以使用负数下标，以<tt class="docutils literal"><span class="pre">-1</span></tt>表示最后一个成员，<tt class="docutils literal"><span class="pre">-2</span></tt>表示倒数第二个成员，以此类推。</div>
</div>
<div class="line-block">
<div class="line">超出范围的下标并不会引起错误。</div>
<div class="line">比如说，当<tt class="docutils literal"><span class="pre">start</span></tt>的值比有序集的最大下标还要大，或是<tt class="docutils literal"><span class="pre">start</span>&nbsp;<span class="pre">&gt;</span>&nbsp;<span class="pre">stop</span></tt>时，<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/sorted_set.html#zrange">ZRANGE</a>命令只是简单地返回一个空列表。</div>
<div class="line">另一方面，假如<tt class="docutils literal"><span class="pre">stop</span></tt>参数的值比有序集的最大下标还要大，那么Redis将<tt class="docutils literal"><span class="pre">stop</span></tt>当作最大下标来处理。</div>
</div>
<div class="line-block">
<div class="line">可以通过使用<tt class="docutils literal"><span class="pre">WITHSCORES</span></tt>选项，来让成员和它的<tt class="docutils literal"><span class="pre">score</span></tt>值一并返回，返回列表以<tt class="docutils literal"><span class="pre">value1,score1,</span>&nbsp;<span class="pre">...,</span>&nbsp;<span class="pre">valueN,scoreN</span></tt>的格式表示。</div>
<div class="line">客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</div>
</div>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(log(N)+M)，<tt class="docutils literal"><span class="pre">N</span></tt>为有序集的基数，而<tt class="docutils literal"><span class="pre">M</span></tt>为结果集的基数。</dd><dt><strong>返回值:</strong></dt><dd>指定区间内，带有<tt class="docutils literal"><span class="pre">score</span></tt>值(可选)的有序集成员的列表。</dd></dl>
<p>&nbsp;</p>
<h2><a name="z_ZREVRANGE"></a>ZREVRANGE</h2>
<dl class="function"><dt><tt class="descname">ZREVRANGE key start stop [WITHSCORES]</tt></dt><dd></dd></dl>
<p>返回有序集<tt class="docutils literal"><span class="pre">key</span></tt>中，指定区间内的成员。</p>
<div class="line-block">
<div class="line">其中成员的位置按<tt class="docutils literal"><span class="pre">score</span></tt>值递减(从大到小)来排列。</div>
<div class="line">具有相同<tt class="docutils literal"><span class="pre">score</span></tt>值的成员按字典序的反序(<a class="reference external" href="http://en.wikipedia.org/wiki/Lexicographical_order#Reverse_lexicographic_order">reverse lexicographical order</a>)排列。</div>
</div>
<p>除了成员按<tt class="docutils literal"><span class="pre">score</span></tt>值递减的次序排列这一点外，<a class="reference internal" href="#z_ZREVRANGE">ZREVRANGE</a>命令的其他方面和<a class="reference internal" href="#z_ZRANGE">ZRANGE</a>命令一样。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(log(N)+M)，<tt class="docutils literal"><span class="pre">N</span></tt>为有序集的基数，而<tt class="docutils literal"><span class="pre">M</span></tt>为结果集的基数。</dd><dt><strong>返回值:</strong></dt><dd>指定区间内，带有<tt class="docutils literal"><span class="pre">score</span></tt>值(可选)的有序集成员的列表。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="z_ZRANGEBYSCORE"></a>ZRANGEBYSCORE</h2>
<dl class="function"><dt><tt class="descname">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</tt></dt><dd></dd></dl>
<p>返回有序集<tt class="docutils literal"><span class="pre">key</span></tt>中，所有<tt class="docutils literal"><span class="pre">score</span></tt>值介于<tt class="docutils literal"><span class="pre">min</span></tt>和<tt class="docutils literal"><span class="pre">max</span></tt>之间(包括等于<tt class="docutils literal"><span class="pre">min</span></tt>或<tt class="docutils literal"><span class="pre">max</span></tt>)的成员。有序集成员按<tt class="docutils literal"><span class="pre">score</span></tt>值递增(从小到大)次序排列。</p>
<p>具有相同<tt class="docutils literal"><span class="pre">score</span></tt>值的成员按字典序(<a class="reference external" href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographical order</a>)来排列(该属性是有序集提供的，不需要额外的计算)。</p>
<p>可选的<tt class="docutils literal"><span class="pre">LIMIT</span></tt>参数指定返回结果的数量及区间(就像SQL中的<tt class="docutils literal"><span class="pre">SELECT</span>&nbsp;<span class="pre">LIMIT</span>&nbsp;<span class="pre">offset,</span>&nbsp;<span class="pre">count</span></tt>)，注意当<tt class="docutils literal"><span class="pre">offset</span></tt>很大时，定位<tt class="docutils literal"><span class="pre">offset</span></tt>的操作可能需要遍历整个有序集，此过程最坏复杂度为O(N)时间。</p>
<div class="line-block">
<div class="line">可选的<tt class="docutils literal"><span class="pre">WITHSCORES</span></tt>参数决定结果集是单单返回有序集的成员，还是将有序集成员及其<tt class="docutils literal"><span class="pre">score</span></tt>值一起返回。</div>
<div class="line">该选项自Redis 2.0版本起可用。</div>
</div>
<p><strong>区间及无限</strong></p>
<p><tt class="docutils literal"><span class="pre">min</span></tt>和<tt class="docutils literal"><span class="pre">max</span></tt>可以是<tt class="docutils literal"><span class="pre">-inf</span></tt>和<tt class="docutils literal"><span class="pre">+inf</span></tt>，这样一来，你就可以在不知道有序集的最低和最高<tt class="docutils literal"><span class="pre">score</span></tt>值的情况下，使用<a class="reference internal" href="#z_ZRANGEBYSCORE">ZRANGEBYSCORE</a>这类命令。</p>
<p>默认情况下，区间的取值使用<a class="reference external" href="http://zh.wikipedia.org/wiki/%E5%8D%80%E9%96%93">闭区间</a>(小于等于或大于等于)，你也可以通过给参数前增加<tt class="docutils literal"><span class="pre">(</span></tt>符号来使用可选的<a class="reference external" href="http://zh.wikipedia.org/wiki/%E5%8D%80%E9%96%93">开区间</a>(小于或大于)。</p>
<p>举个例子：</p>
<p>&nbsp;</p>
<p>返回所有符合条件<tt class="docutils literal"><span class="pre">1</span>&nbsp;<span class="pre">&lt;</span>&nbsp;<span class="pre">score</span>&nbsp;<span class="pre">&lt;=</span>&nbsp;<span class="pre">5</span></tt>的成员；</p>
<p>&nbsp;</p>
<p>返回所有符合条件<tt class="docutils literal"><span class="pre">5</span>&nbsp;<span class="pre">&lt;</span>&nbsp;<span class="pre">score</span>&nbsp;<span class="pre">&lt;</span>&nbsp;<span class="pre">10</span></tt>的成员。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(log(N)+M)，<tt class="docutils literal"><span class="pre">N</span></tt>为有序集的基数，<tt class="docutils literal"><span class="pre">M</span></tt>为被结果集的基数。</dd><dt><strong>返回值:</strong></dt><dd>指定区间内，带有<tt class="docutils literal"><span class="pre">score</span></tt>值(可选)的有序集成员的列表。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="z_ZREVRANGEBYSCORE"></a>ZREVRANGEBYSCORE</h2>
<dl class="function"><dt><tt class="descname">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</tt></dt><dd></dd></dl>
<p>返回有序集<tt class="docutils literal"><span class="pre">key</span></tt>中，<tt class="docutils literal"><span class="pre">score</span></tt>值介于<tt class="docutils literal"><span class="pre">max</span></tt>和<tt class="docutils literal"><span class="pre">min</span></tt>之间(默认包括等于<tt class="docutils literal"><span class="pre">max</span></tt>或<tt class="docutils literal"><span class="pre">min</span></tt>)的所有的成员。有序集成员按<tt class="docutils literal"><span class="pre">score</span></tt>值递减(从大到小)的次序排列。</p>
<p>具有相同<tt class="docutils literal"><span class="pre">score</span></tt>值的成员按字典序的反序(<a class="reference external" href="http://en.wikipedia.org/wiki/Lexicographical_order#Reverse_lexicographic_order">reverse lexicographical order</a>)排列。</p>
<p>除了成员按<tt class="docutils literal"><span class="pre">score</span></tt>值递减的次序排列这一点外，<a class="reference internal" href="#z_ZREVRANGEBYSCORE">ZREVRANGEBYSCORE</a>命令的其他方面和<a class="reference internal" href="#z_ZRANGEBYSCORE">ZRANGEBYSCORE</a>命令一样。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(log(N)+M)，<tt class="docutils literal"><span class="pre">N</span></tt>为有序集的基数，<tt class="docutils literal"><span class="pre">M</span></tt>为结果集的基数。</dd><dt><strong>返回值:</strong></dt><dd>指定区间内，带有<tt class="docutils literal"><span class="pre">score</span></tt>值(可选)的有序集成员的列表。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="z_ZRANK"></a>ZRANK</h2>
<dl class="function"><dt><tt class="descname">ZRANK key member</tt></dt><dd></dd></dl>
<p>返回有序集<tt class="docutils literal"><span class="pre">key</span></tt>中成员<tt class="docutils literal"><span class="pre">member</span></tt>的排名。其中有序集成员按<tt class="docutils literal"><span class="pre">score</span></tt>值递增(从小到大)顺序排列。</p>
<p>排名以<tt class="docutils literal"><span class="pre">0</span></tt>为底，也就是说，<tt class="docutils literal"><span class="pre">score</span></tt>值最小的成员排名为<tt class="docutils literal"><span class="pre">0</span></tt>。</p>
<p>使用<a class="reference internal" href="#z_ZREVRANK">ZREVRANK</a>命令可以获得成员按<tt class="docutils literal"><span class="pre">score</span></tt>值递减(从大到小)排列的排名。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(log(N))</dd><dt><strong>返回值:</strong></dt><dd>
<div class="first last line-block">
<div class="line">如果<tt class="docutils literal"><span class="pre">member</span></tt>是有序集<tt class="docutils literal"><span class="pre">key</span></tt>的成员，返回<tt class="docutils literal"><span class="pre">member</span></tt>的排名。</div>
<div class="line">如果<tt class="docutils literal"><span class="pre">member</span></tt>不是有序集<tt class="docutils literal"><span class="pre">key</span></tt>的成员，返回<tt class="docutils literal"><span class="pre">nil</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="z_ZREVRANK"></a>ZREVRANK</h2>
<dl class="function"><dt><tt class="descname">ZREVRANK key member</tt></dt><dd></dd></dl>
<p>返回有序集<tt class="docutils literal"><span class="pre">key</span></tt>中成员<tt class="docutils literal"><span class="pre">member</span></tt>的排名。其中有序集成员按<tt class="docutils literal"><span class="pre">score</span></tt>值递减(从大到小)排序。</p>
<p>排名以<tt class="docutils literal"><span class="pre">0</span></tt>为底，也就是说，<tt class="docutils literal"><span class="pre">score</span></tt>值最大的成员排名为<tt class="docutils literal"><span class="pre">0</span></tt>。</p>
<p>使用<a class="reference internal" href="#z_ZRANK">ZRANK</a>命令可以获得成员按<tt class="docutils literal"><span class="pre">score</span></tt>值递增(从小到大)排列的排名。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(log(N))</dd><dt><strong>返回值:</strong></dt><dd>
<div class="first last line-block">
<div class="line">如果<tt class="docutils literal"><span class="pre">member</span></tt>是有序集<tt class="docutils literal"><span class="pre">key</span></tt>的成员，返回<tt class="docutils literal"><span class="pre">member</span></tt>的排名。</div>
<div class="line">如果<tt class="docutils literal"><span class="pre">member</span></tt>不是有序集<tt class="docutils literal"><span class="pre">key</span></tt>的成员，返回<tt class="docutils literal"><span class="pre">nil</span></tt>。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="z_ZREMRANGEBYRANK"></a>ZREMRANGEBYRANK</h2>
<dl class="function"><dt><tt class="descname">ZREMRANGEBYRANK key start stop</tt></dt><dd></dd></dl>
<p>移除有序集<tt class="docutils literal"><span class="pre">key</span></tt>中，指定排名(rank)区间内的所有成员。</p>
<p>区间分别以下标参数<tt class="docutils literal"><span class="pre">start</span></tt>和<tt class="docutils literal"><span class="pre">stop</span></tt>指出，包含<tt class="docutils literal"><span class="pre">start</span></tt>和<tt class="docutils literal"><span class="pre">stop</span></tt>在内。</p>
<div class="line-block">
<div class="line">下标参数<tt class="docutils literal"><span class="pre">start</span></tt>和<tt class="docutils literal"><span class="pre">stop</span></tt>都以<tt class="docutils literal"><span class="pre">0</span></tt>为底，也就是说，以<tt class="docutils literal"><span class="pre">0</span></tt>表示有序集第一个成员，以<tt class="docutils literal"><span class="pre">1</span></tt>表示有序集第二个成员，以此类推。</div>
<div class="line">你也可以使用负数下标，以<tt class="docutils literal"><span class="pre">-1</span></tt>表示最后一个成员，<tt class="docutils literal"><span class="pre">-2</span></tt>表示倒数第二个成员，以此类推。</div>
</div>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(log(N)+M)，<tt class="docutils literal"><span class="pre">N</span></tt>为有序集的基数，而<tt class="docutils literal"><span class="pre">M</span></tt>为被移除成员的数量。</dd><dt><strong>返回值:</strong></dt><dd>被移除成员的数量。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="z_ZREMRANGEBYSCORE"></a>ZREMRANGEBYSCORE</h2>
<dl class="function"><dt><tt class="descname">ZREMRANGEBYSCORE key min max</tt></dt><dd></dd></dl>
<p>移除有序集<tt class="docutils literal"><span class="pre">key</span></tt>中，所有<tt class="docutils literal"><span class="pre">score</span></tt>值介于<tt class="docutils literal"><span class="pre">min</span></tt>和<tt class="docutils literal"><span class="pre">max</span></tt>之间(包括等于<tt class="docutils literal"><span class="pre">min</span></tt>或<tt class="docutils literal"><span class="pre">max</span></tt>)的成员。</p>
<p>自版本2.1.6开始，<tt class="docutils literal"><span class="pre">score</span></tt>值等于<tt class="docutils literal"><span class="pre">min</span></tt>或<tt class="docutils literal"><span class="pre">max</span></tt>的成员也可以不包括在内，详情请参见<a class="reference internal" href="#z_ZRANGEBYSCORE">ZRANGEBYSCORE</a>命令。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(log(N)+M)，<tt class="docutils literal"><span class="pre">N</span></tt>为有序集的基数，而<tt class="docutils literal"><span class="pre">M</span></tt>为被移除成员的数量。</dd><dt><strong>返回值:</strong></dt><dd>被移除成员的数量。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="z_ZINTERSTORE"></a>ZINTERSTORE</h2>
<dl class="function"><dt><tt class="descname">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</tt></dt><dd></dd></dl>
<p>计算给定的一个或多个有序集的交集，其中给定<tt class="docutils literal"><span class="pre">key</span></tt>的数量必须以<tt class="docutils literal"><span class="pre">numkeys</span></tt>参数指定，并将该交集(结果集)储存到<tt class="docutils literal"><span class="pre">destination</span></tt>。</p>
<p>默认情况下，结果集中某个成员的<tt class="docutils literal"><span class="pre">score</span></tt>值是所有给定集下该成员<tt class="docutils literal"><span class="pre">score</span></tt>值之<em>和</em>。</p>
<p>关于<tt class="docutils literal"><span class="pre">WEIGHTS</span></tt>和<tt class="docutils literal"><span class="pre">AGGREGATE</span></tt>选项的描述，参见<a class="reference internal" href="http://readthedocs.org/docs/redis/en/latest/sorted_set.html#zunionstore">ZUNIONSTORE</a>命令。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N*K)+O(M*log(M))，<tt class="docutils literal"><span class="pre">N</span></tt>为给定<tt class="docutils literal"><span class="pre">key</span></tt>中基数最小的有序集，<tt class="docutils literal"><span class="pre">K</span></tt>为给定有序集的数量，<tt class="docutils literal"><span class="pre">M</span></tt>为结果集的基数。</dd><dt><strong>返回值:</strong></dt><dd>保存到<tt class="docutils literal"><span class="pre">destination</span></tt>的结果集的基数。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="z_ZUNIONSTORE"></a>ZUNIONSTORE</h2>
<dl class="function"><dt><tt class="descname">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</tt></dt><dd></dd></dl>
<p>计算给定的一个或多个有序集的并集，其中给定<tt class="docutils literal"><span class="pre">key</span></tt>的数量必须以<tt class="docutils literal"><span class="pre">numkeys</span></tt>参数指定，并将该并集(结果集)储存到<tt class="docutils literal"><span class="pre">destination</span></tt>。</p>
<p>默认情况下，结果集中某个成员的<tt class="docutils literal"><span class="pre">score</span></tt>值是所有给定集下该成员<tt class="docutils literal"><span class="pre">score</span></tt>值之<em>和</em>。</p>
<p><strong>WEIGHTS</strong></p>
<p>使用<tt class="docutils literal"><span class="pre">WEIGHTS</span></tt>选项，你可以为<em>每个</em>给定有序集<em>分别</em>指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的<tt class="docutils literal"><span class="pre">score</span></tt>值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。</p>
<p>如果没有指定<tt class="docutils literal"><span class="pre">WEIGHTS</span></tt>选项，乘法因子默认设置为<tt class="docutils literal"><span class="pre">1</span></tt>。</p>
<p><strong>AGGREGATE</strong></p>
<p>使用<tt class="docutils literal"><span class="pre">AGGREGATE</span></tt>选项，你可以指定并集的结果集的聚合方式。</p>
<p>默认使用的参数<tt class="docutils literal"><span class="pre">SUM</span></tt>，可以将所有集合中某个成员的<tt class="docutils literal"><span class="pre">score</span></tt>值之<em>和</em>作为结果集中该成员的<tt class="docutils literal"><span class="pre">score</span></tt>值；使用参数<tt class="docutils literal"><span class="pre">MIN</span></tt>，可以将所有集合中某个成员的<em>最小</em><tt class="docutils literal"><span class="pre">score</span></tt>值作为结果集中该成员的<tt class="docutils literal"><span class="pre">score</span></tt>值；而参数<tt class="docutils literal"><span class="pre">MAX</span></tt>则是将所有集合中某个成员的<em>最大</em><tt class="docutils literal"><span class="pre">score</span></tt>值作为结果集中该成员的<tt class="docutils literal"><span class="pre">score</span></tt>值。</p>
<dl class="docutils"><dt><strong>时间复杂度:</strong></dt><dd>O(N)+O(M log(M))，<tt class="docutils literal"><span class="pre">N</span></tt>为给定有序集基数的总和，<tt class="docutils literal"><span class="pre">M</span></tt>为结果集的基数。</dd><dt><strong>返回值:</strong></dt><dd>保存到<tt class="docutils literal"><span class="pre">destination</span></tt>的结果集的基数。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1><a name="pub_sub"></a>发布/订阅(Pub/Sub)</h1>
<h2><a name="ps_PUBLISH"></a>PUBLISH</h2>
<dl class="function"><dt><tt class="descname">PUBLISH channel message</tt></dt><dd></dd></dl>
<p>将信息&nbsp;<tt class="docutils literal"><span class="pre">message</span></tt>&nbsp;发送到指定的频道&nbsp;<tt class="docutils literal"><span class="pre">channel</span></tt>&nbsp;。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N+M)，其中&nbsp;<tt class="docutils literal"><span class="pre">N</span></tt>&nbsp;是频道&nbsp;<tt class="docutils literal"><span class="pre">channel</span></tt>&nbsp;的订阅者数量，而&nbsp;<tt class="docutils literal"><span class="pre">M</span></tt>&nbsp;则是使用模式订阅(subscribed patterns)的客户端的数量。</dd><dt><strong>返回值：</strong></dt><dd>接收到信息&nbsp;<tt class="docutils literal"><span class="pre">message</span></tt>&nbsp;的订阅者数量。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="ps_SUBSCRIBE"></a>SUBSCRIBE</h2>
<dl class="function"><dt><tt class="descname">SUBSCRIBE channel [channel ...]</tt></dt><dd></dd></dl>
<p>订阅给定频道的信息。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，其中&nbsp;<tt class="docutils literal"><span class="pre">N</span></tt>&nbsp;是订阅的频道的数量。</dd><dt><strong>返回值：</strong></dt><dd>接收到的信息(请参见下面的代码说明)。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="ps_PSUBSCRIBE"></a>PSUBSCRIBE</h2>
<dl class="function"><dt><tt class="descname">PSUBSCRIBE pattern [pattern ...]</tt></dt><dd></dd></dl>
<p>订阅符合给定模式的频道。</p>
<p>每个模式以&nbsp;<tt class="docutils literal"><span class="pre">*</span></tt>&nbsp;作为匹配符，比如&nbsp;<tt class="docutils literal"><span class="pre">huangz*</span></tt>&nbsp;匹配所有以&nbsp;<tt class="docutils literal"><span class="pre">huangz</span></tt>&nbsp;开头的频道(&nbsp;<tt class="docutils literal"><span class="pre">huangzmsg</span></tt>&nbsp;、&nbsp;<tt class="docutils literal"><span class="pre">huangz-blog</span></tt>&nbsp;、&nbsp;<tt class="docutils literal"><span class="pre">huangz.tweets</span></tt>&nbsp;等等)，&nbsp;<tt class="docutils literal"><span class="pre">news.*</span></tt>&nbsp;匹配所有以&nbsp;<tt class="docutils literal"><span class="pre">news.</span></tt>&nbsp;开头的频道(<tt class="docutils literal"><span class="pre">news.it</span></tt>&nbsp;、&nbsp;<tt class="docutils literal"><span class="pre">news.global.today</span></tt>&nbsp;等等)，诸如此类。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，&nbsp;<tt class="docutils literal"><span class="pre">N</span></tt>&nbsp;是订阅的模式的数量。</dd><dt><strong>返回值：</strong></dt><dd>接收到的信息(请参见下面的代码说明)。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="ps_UNSUBSCRIBE"></a>UNSUBSCRIBE</h2>
<blockquote>
<p class="first admonition-title"><span style="color: #ff0000;"><strong>警告:此命令在新版 Redis 中似乎已经被废弃？</strong></span></p>
</blockquote>
<h2><a name="ps_PUNSUBSCRIBE"></a>PUNSUBSCRIBE</h2>
<blockquote>
<p><span style="color: #ff0000;"><strong>警告:此命令在新版 Redis 中似乎已经被废弃？</strong></span></p>
</blockquote>
<p>&nbsp;</p>
<h1><a name="Transaction"></a>事务(Transaction)</h1>
<h2><a name="t_WATCH"></a>WATCH</h2>
<dl class="function"><dt><tt class="descname">ATCH key [key ...]</tt></dt><dd></dd></dl>
<p>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)。</dd><dt><strong>返回值：</strong></dt><dd>总是返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;。</dd></dl>
<p>&nbsp;</p>
<h2><a name="t_UNWATCH"></a>UNWATCH</h2>
<p><strong>UNWATCH</strong></p>
<p>取消&nbsp;<a class="reference internal" href="#t_WATCH">WATCH</a>&nbsp;命令对所有 key 的监视。</p>
<p>如果在执行&nbsp;<a class="reference internal" href="#t_WATCH">WATCH</a>&nbsp;命令之后，&nbsp;<a class="reference internal" href="#t_EXEC">EXEC</a>&nbsp;命令或&nbsp;<a class="reference internal" href="#t_DISCARD">DISCARD</a>&nbsp;命令先被执行了的话，那么就不需要再执行&nbsp;<a class="reference internal" href="#t_UNWATCH">UNWATCH</a>&nbsp;了。</p>
<p>因为&nbsp;<a class="reference internal" href="#t_EXEC">EXEC</a>&nbsp;命令会执行事务，因此&nbsp;<a class="reference internal" href="#t_WATCH">WATCH</a>&nbsp;命令的效果已经产生了；而&nbsp;<a class="reference internal" href="#t_DISCARD">DISCARD</a>&nbsp;命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行&nbsp;<a class="reference internal" href="#t_UNWATCH">UNWATCH</a>&nbsp;了。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>总是&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;。</dd></dl>
<p>&nbsp;</p>
<h2><a name="t_MULTI"></a>MULTI</h2>
<p><strong>MULTI</strong></p>
<p>标记一个事务块的开始。</p>
<p>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由&nbsp;<a class="reference internal" href="#t_EXEC">EXEC</a>&nbsp;命令在一个原子时间内执行。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)。</dd><dt><strong>返回值：</strong></dt><dd>总是返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="t_EXEC"></a>EXEC</h2>
<p><strong>EXEC</strong></p>
<p>执行所有事务块内的命令。</p>
<p>假如某个(或某些) key 正处于&nbsp;<a class="reference internal" href="#t_WATCH">WATCH</a>&nbsp;命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么&nbsp;<a class="reference internal" href="#t_EXEC">EXEC</a>&nbsp;命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>事务块内所有命令的时间复杂度的总和。</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">事务块内所有命令的返回值，按命令执行的先后顺序排列。</div>
<div class="line">当操作被打断时，返回空值&nbsp;<tt class="docutils literal"><span class="pre">nil</span></tt>&nbsp;。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="t_DISCARD"></a>DISCARD</h2>
<p><strong>DISCARD</strong></p>
<p>取消事务，放弃执行事务块内的所有命令。</p>
<p>如果正在使用&nbsp;<a class="reference internal" href="#t_WATCH">WATCH</a>&nbsp;命令监视某个(或某些) key ，那么取消所有监视，等同于执行命令&nbsp;<a class="reference internal" href="#t_UNWATCH">UNWATCH</a>&nbsp;。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)。</dd><dt><strong>返回值：</strong></dt><dd>总是返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1><a name="Connection"></a>连接(Connection)</h1>
<h2><a name="conn_AUTH"></a>AUTH</h2>
<dl class="function"><dt><tt class="descname">AUTH password</tt></dt><dd></dd></dl>
<p>通过设置配置文件中&nbsp;<tt class="docutils literal"><span class="pre">requirepass</span></tt>&nbsp;项的值(使用命令&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">SET</span>&nbsp;<span class="pre">requirepass</span>&nbsp;<span class="pre">password</span></tt>&nbsp;)，可以使用密码来保护 Redis 服务器。</p>
<p>如果开启了密码保护的话，在每次连接 Redis 服务器之后，就要使用&nbsp;<tt class="docutils literal"><span class="pre">AUTH</span></tt>&nbsp;命令解锁，解锁之后才能使用其他 Redis 命令。</p>
<p>如果&nbsp;<tt class="docutils literal"><span class="pre">AUTH</span></tt>&nbsp;命令给定的密码&nbsp;<tt class="docutils literal"><span class="pre">password</span></tt>&nbsp;和配置文件中的密码相符的话，服务器会返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;并开始接受命令输入。</p>
<p>反之，如果密码不匹配的话，服务器将返回一个错误，并要求客户端需重新输入密码。</p>
<div class="admonition warning">
<p class="first admonition-title">&nbsp;</p>
<blockquote>
<p class="last"><span style="color: #ff0000;"><strong>警告:</strong>因为 Redis 高性能的特点，在很短时间内尝试猜测非常多个密码是有可能的，因此请确保使用的密码足够复杂和足够长，以免遭受密码猜测攻击。</span></p>
</blockquote>
</div>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>密码匹配时返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;，否则返回一个错误。</dd></dl>
<p>&nbsp;</p>
<h2><a name="conn_PING"></a>PING</h2>
<p><strong>PING</strong></p>
<p>客户端向服务器发送一个&nbsp;<tt class="docutils literal"><span class="pre">PING</span></tt>&nbsp;，然后服务器返回客户端一个&nbsp;<tt class="docutils literal"><span class="pre">PONG</span></tt>&nbsp;。</p>
<p>通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd><tt class="docutils literal"><span class="pre">PONG</span></tt></dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="conn_SELECT"></a>SELECT</h2>
<dl class="function"><dt><tt class="descname">SELECT index</tt></dt><dd></dd></dl>
<p>切换到指定的数据库，数据库索引号用数字值指定，以&nbsp;<tt class="docutils literal"><span class="pre">0</span></tt>&nbsp;作为起始索引值。</p>
<p>新的链接总是使用&nbsp;<tt class="docutils literal"><span class="pre">0</span></tt>&nbsp;号数据库。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd><tt class="docutils literal"><span class="pre">OK</span></tt></dd></dl>
<p>&nbsp;</p>
<h2><a name="conn_ECHO"></a>ECHO</h2>
<dl class="function"><dt><tt class="descname">ECHO message</tt></dt><dd></dd></dl>
<p>打印一个特定的信息&nbsp;<tt class="docutils literal"><span class="pre">message</span></tt>&nbsp;，测试时使用。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd><tt class="docutils literal"><span class="pre">message</span></tt>&nbsp;自身。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="conn_QUIT"></a>QUIT</h2>
<p><strong>QUIT</strong></p>
<p>请求服务器关闭与当前客户端的连接。</p>
<p>一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>总是返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;(但是不会被打印显示，因为当时 Redis-cli 已经退出)。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1><a name="Server"></a>服务器(Server)</h1>
<h2><a name="svr_BGREWRITEAOF"></a>BGREWRITEAOF</h2>
<p><strong>BGREWRITEAOF</strong></p>
<p>异步(Asynchronously)重写 AOF 文件以反应当前数据库的状态。</p>
<p>即使&nbsp;<a class="reference internal" href="#svr_BGREWRITEAOF">BGREWRITEAOF</a>&nbsp;命令执行失败，旧 AOF 文件中的数据也不会因此丢失或改变。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，&nbsp;<tt class="docutils literal"><span class="pre">N</span></tt>&nbsp;为要追加到 AOF 文件中的数据数量。</dd><dt><strong>返回值：</strong></dt><dd>反馈信息。</dd></dl>
<p>&nbsp;</p>
<h2><a name="svr_BGSAVE"></a>BGSAVE</h2>
<p>在后台异步保存当前数据库的数据到磁盘。</p>
<p><a class="reference internal" href="#svr_BGSAVE">BGSAVE</a>&nbsp;命令执行之后立即返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;，然后 Redis fork出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。</p>
<p>客户端可以通过&nbsp;<a class="reference internal" href="#svr_LASTSAVE">LASTSAVE</a>&nbsp;命令查看相关信息，判断&nbsp;<a class="reference internal" href="#svr_BGSAVE">BGSAVE</a>&nbsp;命令是否执行成功。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，&nbsp;<tt class="docutils literal"><span class="pre">N</span></tt>&nbsp;为要保存到数据库中的 key 的数量。</dd><dt><strong>返回值：</strong></dt><dd>反馈信息。</dd></dl>
<p>&nbsp;</p>
<h2><a name="svr_SAVE"></a>SAVE</h2>
<p><strong>SAVE</strong></p>
<p>同步保存当前数据库的数据到磁盘。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(N)，&nbsp;<tt class="docutils literal"><span class="pre">N</span></tt>&nbsp;为要保存到数据库中的 key 的数量。</dd><dt><strong>返回值：</strong></dt><dd>总是返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="svr_LASTSAVE"></a>LASTSAVE</h2>
<p><strong>LASTSAVE</strong></p>
<p>返回最近一次 Redis 成功执行保存操作的时间点(&nbsp;<a class="reference internal" href="#svr_SAVE">SAVE</a>&nbsp;、&nbsp;<a class="reference internal" href="#svr_BGSAVE">BGSAVE</a>&nbsp;等)，以 UNIX 时间戳格式表示。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>一个 UNIX 时间戳。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="svr_DBSIZE"></a>DBSIZE</h2>
<p><strong>DBSIZE</strong></p>
<p>返回当前数据库的 key 的数量。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>当前数据库的 key 的数量。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="svr_SLAVEOF"></a>SLAVEOF</h2>
<dl class="function"><dt><tt class="descname">SLAVEOF host port</tt></dt><dd></dd></dl>
<p><a class="reference internal" href="#svr_SLAVEOF">SLAVEOF</a>&nbsp;命令用于在 Redis 运行时动态地修改复制(replication)功能的行为。</p>
<p>通过执行&nbsp;<tt class="docutils literal"><span class="pre">SLAVEOF</span>&nbsp;<span class="pre">host</span>&nbsp;<span class="pre">port</span></tt>&nbsp;命令，可以将当前服务器转变为指定服务器的从属服务器(slave server)。</p>
<p>如果当前服务器已经是某个主服务器(master server)的从属服务器，那么执行&nbsp;<tt class="docutils literal"><span class="pre">SLAVEOF</span>&nbsp;<span class="pre">host</span>&nbsp;<span class="pre">port</span></tt>&nbsp;将使当前服务器停止对旧主服务器的同步，丢弃旧数据集，转而开始对新主服务器进行同步。</p>
<p>另外，对一个从属服务器执行命令&nbsp;<tt class="docutils literal"><span class="pre">SLAVEOF</span>&nbsp;<span class="pre">NO</span>&nbsp;<span class="pre">ONE</span></tt>&nbsp;将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集<em>不会</em>被丢弃。</p>
<p>利用&ldquo;&nbsp;<tt class="docutils literal"><span class="pre">SLAVEOF</span>&nbsp;<span class="pre">NO</span>&nbsp;<span class="pre">ONE</span></tt>&nbsp;不会丢弃同步所得数据集&rdquo;这个特性，可以在主服务器失败的时候，将从属服务器用作新的主服务器，从而实现无间断运行。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>
<div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">SLAVEOF</span>&nbsp;<span class="pre">host</span>&nbsp;<span class="pre">port</span></tt>&nbsp;，O(N)，&nbsp;<tt class="docutils literal"><span class="pre">N</span></tt>&nbsp;为要同步的数据数量。</div>
<div class="line"><tt class="docutils literal"><span class="pre">SLAVEOF</span>&nbsp;<span class="pre">NO</span>&nbsp;<span class="pre">ONE</span></tt>&nbsp;， O(1) 。</div>
</div>
</dd><dt><strong>返回值：</strong></dt><dd>总是返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="svr_FLUSHALL"></a>FLUSHALL</h2>
<p><strong>FLUSHALL</strong></p>
<p>清空整个 Redis 服务器的数据(删除<em>所有数据库的所有 key</em>)。</p>
<p>此命令从不失败。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>尚未明确</dd><dt><strong>返回值：</strong></dt><dd>总是返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="svr_FLUSHDB"></a>FLUSHDB</h2>
<p><strong>FLUSHDB</strong></p>
<p>清空<em>当前</em>数据库中的所有 key 。</p>
<p>此命令从不失败。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>总是返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="svr_SHUTDOWN"></a>SHUTDOWN</h2>
<p><strong>SHUTDOWN</strong></p>
<p><a class="reference internal" href="#svr_SHUTDOWN">SHUTDOWN</a>&nbsp;命令执行以下操作：</p>
<ul class="simple">
<li>停止所有客户端</li>
<li>如果有最少一个保存点在等待，执行&nbsp;<a class="reference internal" href="#svr_SAVE">SAVE</a>&nbsp;命令</li>
<li>如果 AOF 选项被打开，更新 AOF 文件</li>
<li>服务器关闭</li>
</ul>
<p>如果持久化被打开的话，&nbsp;<a class="reference internal" href="#svr_SHUTDOWN">SHUTDOWN</a>&nbsp;命令会保证服务器正常关闭而<em>不</em>丢失任何数据。</p>
<p>假如只是单纯地执行&nbsp;<a class="reference internal" href="#svr_SAVE">SAVE</a>&nbsp;命令，然后再执行&nbsp;<a class="reference internal" href="#conn_QUIT"><em>QUIT</em></a>&nbsp;命令，则没有这一保证 &mdash;&mdash; 因为在执行&nbsp;<a class="reference internal" href="#svr_SAVE">SAVE</a>&nbsp;之后、执行&nbsp;<a class="reference internal" href="#conn_QUIT"><em>QUIT</em></a>&nbsp;之前的这段时间中间，其他客户端可能正在和服务器进行通讯，这时如果执行&nbsp;<a class="reference internal" href="#conn_QUIT"><em>QUIT</em></a>&nbsp;就会造成数据丢失。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>不明确</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">执行失败时返回错误。</div>
<div class="line">执行成功时不返回任何信息，服务器和客户端的连接断开，客户端自动退出。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="svr_SLOWLOG"></a>SLOWLOG</h2>
<dl class="function"><dt><tt class="descname">SLOWLOG subcommand [argument]</tt></dt><dd></dd></dl>
<p><strong>什么是 SLOWLOG</strong></p>
<p>Slow log 是 Redis 用来记录查询执行时间的日志系统。</p>
<p>查询执行时间指的是不包括像客户端响应(talking)、发送回复等 IO 操作，而单单是执行一个查询命令所耗费的时间。</p>
<p>另外，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。</p>
<p><strong>设置 SLOWLOG</strong></p>
<p>Slow log 的行为由两个配置参数(configuration parameter)指定，可以通过改写 redis.conf 文件或者用&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">GET</span></tt>&nbsp;和&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">SET</span></tt>&nbsp;命令对它们动态地进行修改。</p>
<p>第一个选项是&nbsp;<tt class="docutils literal"><span class="pre">slowlog-log-slower-then</span></tt>&nbsp;，它决定要对执行时间大于多少微秒(microsecond，1秒 = 1,000,000 微秒)的查询进行记录。</p>
<p>比如执行以下命令将让 slow log 记录所有查询时间大于等于 100 微秒的查询：</p>
<p><tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">SET</span>&nbsp;<span class="pre">slowlog-log-slower-then</span>&nbsp;<span class="pre">100</span></tt>&nbsp;，</p>
<p>而以下命令记录所有查询时间大于 1000 微秒的查询：</p>
<p><tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">SET</span>&nbsp;<span class="pre">slowlog-log-slower-then</span>&nbsp;<span class="pre">1000</span></tt>&nbsp;。</p>
<p>另一个选项是&nbsp;<tt class="docutils literal"><span class="pre">slowlog-max-len</span></tt>&nbsp;，它决定 slow log&nbsp;<em>最多</em>能保存多少条日志， slow log 本身是一个 LIFO 队列，当队列大小超过&nbsp;<tt class="docutils literal"><span class="pre">slowlog-max-len</span></tt>&nbsp;时，最旧的一条日志将被删除，而最新的一条日志加入到 slow log ，以此类推。</p>
<p>以下命令让 slow log 最多保存 1000 条日志：</p>
<p><tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">SET</span>&nbsp;<span class="pre">slowlog-max-len</span>&nbsp;<span class="pre">1000</span></tt>&nbsp;。</p>
<p>使用&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">GET</span></tt>&nbsp;命令可以查询两个选项的当前值：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>查看 slow log</strong></p>
<p>要查看 slow log ，可以使用&nbsp;<tt class="docutils literal"><span class="pre">SLOWLOG</span>&nbsp;<span class="pre">GET</span></tt>&nbsp;或者&nbsp;<tt class="docutils literal"><span class="pre">SLOWLOG</span>&nbsp;<span class="pre">GET</span>&nbsp;<span class="pre">number</span></tt>&nbsp;命令，前者打印所有 slow log ，最大长度取决于&nbsp;<tt class="docutils literal"><span class="pre">slowlog-max-len</span></tt>&nbsp;选项的值，而&nbsp;<tt class="docutils literal"><span class="pre">SLOWLOG</span>&nbsp;<span class="pre">GET</span>&nbsp;<span class="pre">number</span></tt>&nbsp;则只打印指定数量的日志。</p>
<p>最新的日志会最先被打印：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>日志的唯一 id 只有在 Redis 服务器重启的时候才会重置，这样可以避免对日志的重复处理(比如你可能会想在每次发现新的慢查询时发邮件通知你)。</p>
<p><strong>查看当前日志的数量</strong></p>
<p>使用命令&nbsp;<tt class="docutils literal"><span class="pre">SLOWLOG</span>&nbsp;<span class="pre">LEN</span></tt>&nbsp;可以查看当前日志的数量。</p>
<p>请注意这个值和&nbsp;<tt class="docutils literal"><span class="pre">slower-max-len</span></tt>&nbsp;的区别，它们一个是当前日志的数量，一个是允许记录的最大日志的数量。</p>
<p>&nbsp;</p>
<p><strong>清空日志</strong></p>
<p>使用命令&nbsp;<tt class="docutils literal"><span class="pre">SLOWLOG</span>&nbsp;<span class="pre">RESET</span></tt>&nbsp;可以清空 slow log 。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>时间复杂度：</strong>O(1)</p>
<p><strong>返回值：</strong>取决于不同命令，返回不同的值。</p>
<p>&nbsp;</p>
<h2><a name="svr_INFO"></a>INFO</h2>
<p><strong>INFO</strong></p>
<p>返回关于 Redis 服务器的各种信息和统计值。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>具体请参见下面的测试代码。</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="svr_CONFIG-GET"></a>CONFIG GET</h2>
<dl class="function"><dt><tt class="descname">CONFIG GET parameter</tt></dt><dd></dd></dl>
<p><a class="reference internal" href="#svr_CONFIG-GET">CONFIG GET</a>&nbsp;命令用于取得运行中的 Redis 服务器的配置参数(configuration parameters)，不过并非所有配置参数都被&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">GET</span></tt>&nbsp;命令所支持。</p>
<p><a class="reference internal" href="#svr_CONFIG-GET">CONFIG GET</a>&nbsp;接受单个参数&nbsp;<tt class="docutils literal"><span class="pre">parameter</span></tt>&nbsp;作为搜索关键字，查找所有匹配的配置参数，其中参数和值以&ldquo;键-值对&rdquo;(key-value pairs)的方式排列。</p>
<p>比如执行&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">GET</span>&nbsp;<span class="pre">s*</span></tt>&nbsp;命令，服务器就会返回所有以&nbsp;<tt class="docutils literal"><span class="pre">s</span></tt>&nbsp;开头的配置参数及参数的值：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>如果你只是寻找特定的某个参数的话，你当然也可以直接指定参数的名字：</p>
<p>&nbsp;</p>
<p>使用命令&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">GET</span>&nbsp;<span class="pre">*</span></tt>&nbsp;，可以列出&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">GET</span></tt>&nbsp;命令支持的所有参数：</p>
<p>&nbsp;</p>
<p>所有被&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">SET</span></tt>&nbsp;所支持的配置参数都可以在配置文件 redis.conf 中找到，不过&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">GET</span></tt>&nbsp;和&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">SET</span></tt>&nbsp;使用的格式和 redis.conf 文件所使用的格式有以下两点不同：</p>
<ul>
<li>
<div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">10kb</span></tt>&nbsp;、&nbsp;<tt class="docutils literal"><span class="pre">2gb</span></tt>&nbsp;这些在配置文件中所使用的储存单位缩写，不可以用在&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span></tt>&nbsp;命令中，&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">SET</span></tt>&nbsp;的值只能通过数字值显式地设定。</div>
<div class="line">&nbsp;</div>
<div class="line">像&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">SET</span>&nbsp;<span class="pre">xxx</span>&nbsp;<span class="pre">1k</span></tt>&nbsp;这样的命令是错误的，正确的格式是&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">SET</span>&nbsp;<span class="pre">xxx</span>&nbsp;<span class="pre">1000</span></tt>&nbsp;。</div>
</div>
</li>
<li>
<div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">save</span></tt>&nbsp;选项在 redis.conf 中是用多行文字储存的，但在&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">GET</span></tt>&nbsp;命令中，它只打印一行文字。</div>
<div class="line">&nbsp;</div>
<div class="line">以下是&nbsp;<tt class="docutils literal"><span class="pre">save</span></tt>&nbsp;选项在 redis.conf 文件中的表示：</div>
<div class="line">&nbsp;</div>
<div class="line"><tt class="docutils literal"><span class="pre">save</span>&nbsp;<span class="pre">900</span>&nbsp;<span class="pre">1</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">save</span>&nbsp;<span class="pre">300</span>&nbsp;<span class="pre">10</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">save</span>&nbsp;<span class="pre">60</span>&nbsp;<span class="pre">10000</span></tt></div>
<div class="line">&nbsp;</div>
<div class="line">但是&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">GET</span></tt>&nbsp;命令的输出只有一行：</div>
<div class="line">&nbsp;</div>
<div class="line"><tt class="docutils literal"><span class="pre">redis&gt;</span>&nbsp;<span class="pre">CONFIG</span>&nbsp;<span class="pre">GET</span>&nbsp;<span class="pre">save</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">1)</span>&nbsp;<span class="pre">"save"</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">2)</span>&nbsp;<span class="pre">"900</span>&nbsp;<span class="pre">1</span>&nbsp;<span class="pre">300</span>&nbsp;<span class="pre">10</span>&nbsp;<span class="pre">60</span>&nbsp;<span class="pre">10000"</span></tt></div>
<div class="line">&nbsp;</div>
<div class="line">上面&nbsp;<tt class="docutils literal"><span class="pre">save</span></tt>&nbsp;参数的三个值表示：在 900 秒内最少有 1 个 key 被改动，或者 300 秒内最少有 10 个 key 被改动，又或者 60 秒内最少有 1000 个 key 被改动，以上三个条件随便满足一个，就触发一次保存操作。</div>
</div>
</li>
</ul>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>不明确</dd><dt><strong>返回值：</strong></dt><dd>给定配置参数的值。</dd></dl>
<p>&nbsp;</p>
<h2><a name="scr_CONFIG-SET"></a>CONFIG SET</h2>
<dl class="function"><dt><tt class="descname">CONFIG SET parameter value</tt></dt><dd></dd></dl>
<p><a class="reference internal" href="#scr_CONFIG-SET">CONFIG SET</a>&nbsp;命令可以动态地调整 Redis 服务器的配置(configuration)而无须重启。</p>
<p>你可以使用它修改配置参数，或者改变 Redis 的持久化(Persistence)方式。</p>
<p><a class="reference internal" href="#scr_CONFIG-SET">CONFIG SET</a>&nbsp;可以修改的配置参数可以使用命令&nbsp;<tt class="docutils literal"><span class="pre">CONFIG</span>&nbsp;<span class="pre">GET</span>&nbsp;<span class="pre">*</span></tt>&nbsp;来列出，所有被&nbsp;<a class="reference internal" href="#scr_CONFIG-SET">CONFIG SET</a>&nbsp;修改的配置参数都会立即生效。</p>
<p>关于&nbsp;<a class="reference internal" href="#scr_CONFIG-SET">CONFIG SET</a>&nbsp;命令的更多消息，请参见命令&nbsp;<a class="reference internal" href="#svr_CONFIG-GET">CONFIG GET</a>&nbsp;的说明。</p>
<p>关于如何使用&nbsp;<a class="reference internal" href="#scr_CONFIG-SET">CONFIG SET</a>&nbsp;命令修改 Redis 持久化方式，请参见&nbsp;<a class="reference external" href="http://redis.io/topics/persistence">Redis Persistence</a>&nbsp;。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>不明确</dd><dt><strong>返回值：</strong></dt><dd>当设置成功时返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;，否则返回一个错误。</dd></dl>
<p>&nbsp;</p>
<h2><a name="scr_CONFIG-RESETSTAT"></a>CONFIG RESETSTAT</h2>
<dl class="function"><dt><tt class="descname">CONFIG RESETSTAT</tt></dt><dd></dd></dl>
<p>重置&nbsp;<a class="reference internal" href="#svr_INFO">INFO</a>&nbsp;命令中的某些统计数据，包括：</p>
<ul class="simple">
<li>Keyspace hits (键空间命中次数)</li>
<li>Keyspace misses (键空间不命中次数)</li>
<li>Number of commands processed (执行命令的次数)</li>
<li>Number of connections received (连接服务器的次数)</li>
<li>Number of expired keys (过期key的数量)</li>
</ul>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>总是返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;。</dd></dl>
<p>&nbsp;</p>
<h2><a name="scr_DEBUG-OBJECT"></a>DEBUG OBJECT</h2>
<dl class="function"><dt><tt class="descname">DEBUG OBJECT key</tt></dt><dd></dd></dl>
<p>返回给定&nbsp;<tt class="docutils literal"><span class="pre">key</span></tt>&nbsp;的调试信息。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>O(1)</dd><dt><strong>返回值：</strong></dt><dd>
<div class="first last line-block">
<div class="line">当&nbsp;<tt class="docutils literal"><span class="pre">key</span></tt>&nbsp;存在时，返回有关信息。</div>
<div class="line">当&nbsp;<tt class="docutils literal"><span class="pre">key</span></tt>&nbsp;不存在时，返回一个错误。</div>
</div>
</dd></dl>
<p>&nbsp;</p>
<h2><a name="svr_DEBUG-SEGFAULT"></a>DEBUG SEGFAULT</h2>
<dl class="function"><dt><tt class="descname">DEBUG SEGFAULT</tt></dt><dd></dd></dl>
<p>令 Redis 服务器崩溃，调试用。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>不明确</dd><dt><strong>返回值：</strong></dt><dd>无</dd></dl>
<p>&nbsp;</p>
<h2><a name="svr_MONITOR"></a>MONITOR</h2>
<p><strong>MONITOR</strong></p>
<p>实时打印出 Redis 服务器接收到的命令，调试用。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>不明确</dd><dt><strong>返回值：</strong></dt><dd>总是返回&nbsp;<tt class="docutils literal"><span class="pre">OK</span></tt>&nbsp;。</dd></dl>
<p>&nbsp;</p>
<h2><a name="svr_SYNC"></a>SYNC</h2>
<p><strong>YNC</strong></p>
<p>用于复制功能(replication)的内部命令。</p>
<dl class="docutils"><dt><strong>时间复杂度：</strong></dt><dd>不明确</dd><dt><strong>返回值：</strong></dt><dd>不明确</dd></dl></div></div><div id="MySignature"></div>
<hr>
<h3 class="catListTitle">公告</h3>
Copyright &copy;2015 春哥也编程 <a href='http://www.cnblogs.com/zcy_soft/'>春哥也编程</a>
<p>power by redis中文手册：<a href="http://readthedocs.org/docs/redis/en/latest/" target="_blank">http://readthedocs.org/docs/redis/en/latest/</a>&nbsp;</p>
	</div>
</div>
</body>
</html>
